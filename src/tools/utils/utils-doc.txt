------------------------------------------------------------------
tools/utils/ANSI_FMT.hpp
ANSI Formatter Documentation

Overview
The tools::utils namespace provides a set of ANSI escape code macros for formatting terminal output with text styles 
and colors. These utilities enable developers to enhance console applications with bold text, colored output, and 
background highlights, improving readability and user experience. The macros are lightweight, defined as 
preprocessor constants, and can be combined to create custom formatting styles.
Namespace: tools::utils

Key Components

Text Formatting Macros
- Purpose: Apply styling to text output in terminals that support ANSI escape codes.
- Available Macros:
  - ANSI_FMT_T_BOLD: "\033[1m" - Bold text.
  - ANSI_FMT_T_DIM: "\033[2m" - Dim (faint) text.
  - ANSI_FMT_T_UNDERLINE: "\033[4m" - Underlined text.
  - ANSI_FMT_T_BLINK: "\033[5m" - Blinking text (not widely supported).
  - ANSI_FMT_T_REVERSE: "\033[7m" - Reverse video (swap foreground and background).
  - ANSI_FMT_T_HIDDEN: "\033[8m" - Hidden text (e.g., for passwords).

Text Color Macros
- Purpose: Set the foreground color of text.
- Available Macros:
  - ANSI_FMT_C_BLACK: "\033[30m" - Black text.
  - ANSI_FMT_C_RED: "\033[31m" - Red text.
  - ANSI_FMT_C_GREEN: "\033[32m" - Green text.
  - ANSI_FMT_C_YELLOW: "\033[33m" - Yellow text.
  - ANSI_FMT_C_BLUE: "\033[34m" - Blue text.
  - ANSI_FMT_C_MAGENTA: "\033[35m" - Magenta text.
  - ANSI_FMT_C_CYAN: "\033[36m" - Cyan text.
  - ANSI_FMT_C_WHITE: "\033[37m" - White text.

Background Color Macros
- Purpose: Set the background color behind text.
- Available Macros:
  - ANSI_FMT_B_BLACK: "\033[40m" - Black background.
  - ANSI_FMT_B_RED: "\033[41m" - Red background.
  - ANSI_FMT_B_GREEN: "\033[42m" - Green background.
  - ANSI_FMT_B_YELLOW: "\033[43m" - Yellow background.
  - ANSI_FMT_B_BLUE: "\033[44m" - Blue background.
  - ANSI_FMT_B_MAGENTA: "\033[45m" - Magenta background.
  - ANSI_FMT_B_CYAN: "\033[46m" - Cyan background.
  - ANSI_FMT_B_WHITE: "\033[47m" - White background.

Utility Macros
- ANSI_FMT_RESET: "\033[0m" - Resets all formatting to default.
- ANSI_FMT(fmt, text): Combines a format string with text and appends a reset code.
  - Definition: (string(fmt) + text + ANSI_FMT_RESET)
  - Returns: A string with the formatted text, ensuring styles don’t bleed into subsequent output.

Predefined Themes
- Purpose: User-specific combinations of formatting for common use cases.
- Available Themes:
  - ANSI_FMT_FNAME: ANSI_FMT_T_BOLD ANSI_FMT_C_WHITE - Bold white text (e.g., for filenames).
  - ANSI_FMT_ERROR: ANSI_FMT_T_BOLD ANSI_FMT_C_RED - Bold red text (e.g., for error messages).
  - ANSI_FMT_DEBUG: ANSI_FMT_C_BLACK - Black text (e.g., for debug output).

Usage

1. Basic Text Formatting
Apply a single style or color to text using the macros directly.
Example:
        #include "tools/utils/ANSI_FMT.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            cout << ANSI_FMT_T_BOLD << "Bold text" << ANSI_FMT_RESET << endl;
            cout << ANSI_FMT_C_RED << "Red text" << ANSI_FMT_RESET << endl;
            cout << ANSI_FMT_B_GREEN << "Green background" << ANSI_FMT_RESET << endl;
            return 0;
        }

2. Combining Formats
Combine multiple macros to create complex styles, ensuring ANSI_FMT_RESET is appended.
Example:
        #include "tools/utils/ANSI_FMT.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            string format = ANSI_FMT_T_BOLD ANSI_FMT_C_BLUE ANSI_FMT_B_YELLOW;
            cout << format << "Bold blue text on yellow" << ANSI_FMT_RESET << endl;
            return 0;
        }

3. Using ANSI_FMT Macro
Use the ANSI_FMT macro to wrap text with formatting and automatically reset it.
Example:
        #include "tools/utils/ANSI_FMT.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            string formatted = ANSI_FMT(ANSI_FMT_C_GREEN, "Green text");
            cout << formatted << " followed by normal text" << endl;
            return 0;
        }

4. Predefined Themes
Leverage predefined themes for consistent formatting across your application.
Example:
        #include "tools/utils/ANSI_FMT.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            cout << ANSI_FMT_FNAME << "example.txt" << ANSI_FMT_RESET << endl;
            cout << ANSI_FMT_ERROR << "Error occurred!" << ANSI_FMT_RESET << endl;
            cout << ANSI_FMT_DEBUG << "Debug info" << ANSI_FMT_RESET << endl;
            return 0;
        }

Advanced Usage

Custom Themes
- Define new themes by combining existing macros in your code.
Example:
        #include "tools/utils/ANSI_FMT.hpp"
        using namespace std;
        using namespace tools::utils;
        #define ANSI_FMT_WARNING ANSI_FMT_T_BOLD ANSI_FMT_C_YELLOW
        int main() {
            cout << ANSI_FMT_WARNING << "Warning: Check input" << ANSI_FMT_RESET << endl;
            return 0;
        }

Conditional Formatting
- Apply formatting based on runtime conditions for dynamic output.
Example:
        #include "tools/utils/ANSI_FMT.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            int status = 1;
            string msg = (status == 0) ? ANSI_FMT(ANSI_FMT_C_GREEN, "Success") 
                                      : ANSI_FMT(ANSI_FMT_C_RED, "Failure");
            cout << msg << endl;
            return 0;
        }

Best Practices
- Always append ANSI_FMT_RESET after formatted text to prevent style bleed into subsequent output.
- Test on ANSI-compatible terminals (e.g., Linux/macOS terminals, Windows Terminal with VT support); non-compatible 
terminals (e.g., older cmd.exe) may display escape codes as garbage.
- Avoid overusing blinking text (ANSI_FMT_T_BLINK) due to limited support and potential annoyance.
- Use predefined themes for consistency in large projects.

Dependencies
- Internal: None beyond standard C++ library (<string>).
- External: None; relies on terminal support for ANSI escape codes.

Contributing
- Add new ANSI codes for additional styles (e.g., italic: "\033[3m") or bright colors (e.g., "\033[91m" for bright 
red).
- Submit enhancements to src/tools/utils/ANSI_FMT.hpp in the project repository.

------------------------------------------------------------------
tools/utils/Arguments.hpp
Arguments Documentation

Overview
The tools::utils::Arguments class provides a simple and robust way to parse and access command-line arguments in C++. 
It encapsulates the traditional argc/argv pair into a vector of strings and offers methods to check for flags, 
retrieve values (boolean, string, or integer), and access arguments by position. Designed for ease of use, it 
includes error handling via exceptions for missing or invalid values, making it suitable for command-line 
applications requiring straightforward argument processing.
Namespace: tools::utils

Key Components

Constructor
- Signature: Arguments(int argc, char* argv[])
- Purpose: Initializes the class by converting command-line arguments into a vector of strings.
- Behavior: Each argv element is stored as a string, including the program name (argv[0]).

Methods
- bool has(const string& arg) const
  - Checks if a flag (prefixed with "--") exists in the arguments.
  - Returns: true if found, false otherwise.
- long int indexOf(const string& arg) const
  - Finds the index of a flag (prefixed with "--") in the argument list.
  - Returns: Index if found, -1 if not found.
- bool getBool(const string& key) const
  - Interprets the presence of a flag as a true value.
  - Returns: true if the flag exists, false otherwise.
- const string getString(const string& key) const
  - Retrieves the string value following a flag.
  - Throws: ERROR if the flag is missing or has no following value.
- const string getString(size_t at) const
  - Retrieves the string at a specific position in the argument list.
  - Throws: ERROR if the position is out of bounds.
- int getInt(const string& key) const
  - Retrieves an integer value following a flag by converting the string result of getString().
  - Throws: ERROR if the value is missing, not an integer, or conversion fails.

Usage

1. Checking for Flags
Verify the presence of a flag using has() or getBool().
Example:
        #include "tools/utils/Arguments.hpp"
        using namespace std;
        using namespace tools::utils;
        int main(int argc, char* argv[]) {
            Arguments args(argc, argv);
            if (args.has("verbose")) {
                cout << "Verbose mode enabled" << endl;
            }
            return 0;
        }

2. Retrieving String Values
Get a string value associated with a flag or by position.
Example:
        #include "tools/utils/Arguments.hpp"
        using namespace std;
        using namespace tools::utils;
        int main(int argc, char* argv[]) {
            Arguments args(argc, argv);
            try {
                string value = args.getString("file");
                cout << "File: " << value << endl;
                string first_arg = args.getString(0); // Program name
                cout << "Program: " << first_arg << endl;
            } catch (const ERROR& e) {
                cerr << "Error: " << e.what() << endl;
            }
            return 0;
        }

3. Retrieving Integer Values
Get an integer value following a flag with error handling for invalid inputs.
Example:
        #include "tools/utils/Arguments.hpp"
        using namespace std;
        using namespace tools::utils;
        int main(int argc, char* argv[]) {
            Arguments args(argc, argv);
            try {
                int count = args.getInt("count");
                cout << "Count: " << count << endl;
            } catch (const ERROR& e) {
                cerr << "Error: " << e.what() << endl;
            }
            return 0;
        }

Advanced Usage

Combining Methods
- Use indexOf() to locate a flag and then conditionally fetch values based on its position.
Example:
        #include "tools/utils/Arguments.hpp"
        using namespace std;
        using namespace tools::utils;
        int main(int argc, char* argv[]) {
            Arguments args(argc, argv);
            long int idx = args.indexOf("mode");
            if (idx != -1 && idx + 1 < argc) {
                string mode = args.getString("mode");
                cout << "Mode: " << mode << endl;
            } else {
                cout << "Default mode" << endl;
            }
            return 0;
        }

Error Handling
- Wrap calls to getString() and getInt() in try-catch blocks to handle missing or invalid arguments gracefully.
Example:
        #include "tools/utils/Arguments.hpp"
        using namespace std;
        using namespace tools::utils;
        int main(int argc, char* argv[]) {
            Arguments args(argc, argv);
            try {
                int port = args.getInt("port");
                cout << "Port: " << port << endl;
            } catch (const ERROR& e) {
                cerr << "Invalid or missing port: " << e.what() << endl;
                return 1;
            }
            return 0;
        }

Best Practices
- Prefix flags with "--" in your application, as Arguments expects this convention (e.g., "--verbose", not "-v").
- Use getBool() for flags without values and getString()/getInt() for flags requiring values.
- Handle exceptions to provide user-friendly error messages, especially for required arguments.
- Test edge cases (e.g., missing values, invalid integers) as shown in the provided unit tests.

Dependencies
- Internal: tools::utils::ERROR (exception class), tools::utils::strings (str_contains in tests).
- External: Standard C++ libraries (<vector>, <string>, <algorithm>).

Testing
- The class includes comprehensive unit tests under #ifdef TEST, covering:
  - Flag presence (has(), getBool())
  - Index lookup (indexOf())
  - String retrieval (getString() by key and position)
  - Integer parsing (getInt())
  - Error conditions (missing values, invalid integers)
- Tests simulate argc/argv using vector<char*> for realistic behavior.

------------------------------------------------------------------
tools/utils/Curl.hpp
Curl Documentation

Overview
The tools::utils::Curl class is a C++ wrapper around the libcurl library, providing a simplified interface for making 
HTTP requests (GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS) with streaming support. It enables asynchronous data 
processing via callbacks, supports request cancellation, and offers configuration options for headers, SSL 
verification, proxies, and timeouts. Designed for ease of use and thread safety, it’s ideal for applications 
requiring network communication, such as API clients or web scrapers.
Namespace: tools::utils

Key Components

Constructor and Destructor
- Constructor: Curl()
  - Initializes libcurl globally using curl_global_init() in a thread-safe manner (via call_once).
- Destructor: ~Curl()
  - Default destructor; does not perform cleanup of global libcurl state (handled by the OS or explicit 
curl_global_cleanup() if needed elsewhere).

Core Method
- bool Request(Method method, const string& url, const StreamCallback& callback, const vector<string>& req_headers 
= {}, const string& data = "")
  - Executes an HTTP request with the specified method, URL, callback for streaming response data, optional headers, 
and optional request body.
  - Returns: true on success, false on failure (e.g., curl_easy_init fails or CURLcode indicates an error).
  - Callback: StreamCallback (function<void(const string& chunk)>) processes response chunks as they arrive.

Convenience Methods
- bool GET(const string& url, const StreamCallback& callback, const vector<string>& headers = {})
- bool POST(const string& url, const StreamCallback& callback, const string& data, const vector<string>& headers = 
{})
- bool PUT(const string& url, const StreamCallback& callback, const string& data, const vector<string>& headers = 
{})
- bool DELETE(const string& url, const StreamCallback& callback, const vector<string>& headers = {})
- bool PATCH(const string& url, const StreamCallback& callback, const string& data, const vector<string>& headers = 
{})
- bool HEAD(const string& url, const StreamCallback& callback, const vector<string>& headers = {})
- bool OPTIONS(const string& url, const StreamCallback& callback, const vector<string>& headers = {})
  - Simplified wrappers around Request() for specific HTTP methods.

Configuration Methods
- void SetFollowRedirects(bool enable, int max_redirects = 5): Enables/disables redirect following and sets max 
redirects.
- void SetAutoDecompress(bool enable): Enables/disables automatic decompression of compressed responses.
- void SetDNSCaching(long ttl_seconds): Sets DNS cache timeout in seconds.
- void SetVerifySSL(bool verify): Enables/disables SSL peer and host verification.
- void SetTimeout(long milliseconds): Sets request timeout in milliseconds.
- void AddHeader(const string& header): Adds a persistent header to all requests.
- void ClearHeaders(): Clears all persistent headers.
- void SetProxy(const string& proxy_server): Sets a proxy server for requests.

Cancellation
- void cancel(): Sets a flag to abort ongoing requests (checked in WriteHandler).

Usage

1. Basic GET Request
Fetch data from a URL and process it in chunks.
Example:
        #include "tools/utils/Curl.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            Curl curl;
            bool success = curl.GET("https://example.com", [](const string& chunk) {
                cout << "Received: " << chunk << endl;
            });
            if (!success) {
                cerr << "GET request failed" << endl;
            }
            return 0;
        }

2. POST Request with Data
Send data to a server and stream the response.
Example:
        #include "tools/utils/Curl.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            Curl curl;
            string data = "key=value";
            curl.AddHeader("Content-Type: application/x-www-form-urlencoded");
            bool success = curl.POST("https://example.com/api", [](const string& chunk) {
                cout << chunk;
            }, data);
            if (!success) {
                cerr << "POST request failed" << endl;
            }
            return 0;
        }

3. Configured Request with Timeout and Proxy
Make a request with custom settings.
Example:
        #include "tools/utils/Curl.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            Curl curl;
            curl.SetTimeout(5000); // 5 seconds
            curl.SetProxy("http://proxy.example.com:8080");
            curl.SetVerifySSL(false); // Disable SSL verification (not recommended for production)
            bool success = curl.GET("https://example.com", [](const string& chunk) {
                cout << "Chunk: " << chunk << endl;
            });
            if (!success) {
                cerr << "Request failed" << endl;
            }
            return 0;
        }

Advanced Usage

Streaming Large Responses
- Use the StreamCallback to process data incrementally, ideal for large files or real-time data.
Example:
        #include "tools/utils/Curl.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            Curl curl;
            string full_response;
            bool success = curl.GET("https://example.com/largefile", [&full_response](const string& chunk) {
                full_response += chunk;
                cout << "Chunk size: " << chunk.size() << endl;
            });
            if (success) {
                cout << "Total size: " << full_response.size() << endl;
            }
            return 0;
        }

Cancelling Requests
- Abort a request mid-execution using cancel().
Example:
        #include "tools/utils/Curl.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            Curl curl;
            thread t([&curl]() {
                sleep(1); // Simulate delay
                curl.cancel();
                cout << "Request cancelled" << endl;
            });
            bool success = curl.GET("https://example.com/slow", [](const string& chunk) {
                cout << "Received: " << chunk << endl;
            });
            t.join();
            if (!success) {
                cout << "Request was cancelled or failed" << endl;
            }
            return 0;
        }

Thread Safety
- Configuration methods (Set* and AddHeader) are thread-safe via mutex locks.
- Multiple Curl instances can be used concurrently, but a single instance’s Request() calls are not thread-safe 
(serialize access if needed).
- The cancel() method is thread-safe and can be called from another thread to abort a request.

Error Handling
- Request() returns false on failure, with error details printed to cerr (CURLcode and error message).
- Check return values and handle failures appropriately in production code.

Dependencies
- Internal: None beyond standard C++ libraries (<iostream>, <string>, etc.).
- External: libcurl (required for compilation and linking).

Contributing
- Add support for progress callbacks (ProgressCallback is defined but unused in the current code).
- Implement retry logic for transient failures.
- Submit enhancements to src/tools/utils/Curl.hpp in the project repository.

------------------------------------------------------------------
tools/utils/datetime.hpp
Datetime Documentation

Overview
The tools::utils datetime utilities provide a comprehensive set of functions and constants for working with time and 
date in C++. It includes functionality to retrieve current time, parse and format datetime strings, validate datetime 
formats, and convert between milliseconds, seconds, and human-readable strings. Designed for flexibility and 
robustness, it supports custom time retrieval functions, timezone options, and interval parsing, making it suitable 
for applications requiring precise time manipulation.
Namespace: tools::utils

Key Components

Types and Constants
- Types:
  - time_ms: typedef long long - Represents time in milliseconds.
  - time_sec: typedef long long - Represents time in seconds.
- Constants:
  - second_ms, minute_ms, hour_ms, day_ms, week_ms: Millisecond durations (e.g., second_ms = 1000).
  - minute_sec, hour_sec, day_sec, week_sec: Second durations (e.g., minute_sec = 60).

Time Retrieval Functions
- time_t (*get_time_ms)(): Function pointer to retrieve current time in milliseconds (default: chrono-based).
- time_t (*get_time_sec)(): Function pointer to retrieve current time in seconds (default: get_time_ms() / 1000).

Datetime Validation and Normalization
- bool is_valid_datetime(const string& datetime): Validates a datetime string (e.g., "YYYY-MM-DD HH:MM:SS.sss").
- string normalize_datetime(const string& datetime): Normalizes a datetime string to "YYYY-MM-DD HH:MM:SS.sss" format.

Conversion Functions
- time_t datetime_to_ms(const string& datetime): Converts a datetime string to milliseconds since epoch.
- time_t date_to_ms(const string& date): Alias for datetime_to_ms() for date-only strings.
- time_t datetime_to_sec(const string& date): Converts a datetime string to seconds since epoch.
- time_t date_to_sec(const string& date): Converts a date string to seconds since epoch.
- string ms_to_datetime(time_t ms = get_time_ms(), const char* fmt = "%Y-%m-%d %H:%M:%S", bool millis = true, bool 
local = false): Converts milliseconds to a formatted string.
- string sec_to_datetime(time_t sec, const char* fmt = "%Y-%m-%d %H:%M:%S", bool local = false): Converts seconds to 
a formatted string.
- string ms_to_date(time_t ms = get_time_ms(), const char* fmt = "%Y-%m-%d", bool local = false): Converts 
milliseconds to a date string.
- string sec_to_date(time_t sec, const char* fmt = "%Y-%m-%d", bool local = false): Converts seconds to a date string.

Deprecated Functions
- time_t date_parse_ms(const string& date_string): Deprecated; use datetime_to_ms() instead.
- time_t date_parse_sec(const string& date_string): Deprecated; use date_to_sec() instead.

Utility Functions
- time_t get_day_first_sec(time_t sec = get_time_sec()): Returns the timestamp of midnight for a given day.
- time_t interval_to_sec(const string& interval_str): Converts an interval string (e.g., "5m") to seconds.

Usage

1. Retrieving Current Time
Get the current time in milliseconds or seconds.
Example:
        #include "tools/utils/datetime.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            time_ms ms = get_time_ms();
            time_sec sec = get_time_sec();
            cout << "Current time (ms): " << ms << endl;
            cout << "Current time (sec): " << sec << endl;
            return 0;
        }

2. Formatting Current Time
Convert the current time to a readable string.
Example:
        #include "tools/utils/datetime.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            string dt = ms_to_datetime(); // Default: "YYYY-MM-DD HH:MM:SS.sss"
            string date = ms_to_date();   // Default: "YYYY-MM-DD"
            cout << "Datetime: " << dt << endl;
            cout << "Date: " << date << endl;
            return 0;
        }

3. Parsing Datetime Strings
Convert a datetime string to milliseconds or seconds.
Example:
        #include "tools/utils/datetime.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            try {
                time_ms ms = datetime_to_ms("2023-10-05 14:30:45.123");
                time_sec sec = datetime_to_sec("2023-10-05 14:30:45.123");
                cout << "Milliseconds: " << ms << endl;
                cout << "Seconds: " << sec << endl;
            } catch (const ERROR& e) {
                cerr << "Error: " << e.what() << endl;
            }
            return 0;
        }

Advanced Usage

Custom Time Retrieval
- Override get_time_ms() or get_time_sec() for mock or custom time sources.
Example:
        #include "tools/utils/datetime.hpp"
        using namespace std;
        using namespace tools::utils;
        time_t mock_time_ms() { return 1696516245123LL; } // "2023-10-05 14:30:45.123"
        int main() {
            auto original = get_time_ms;
            get_time_ms = mock_time_ms;
            cout << ms_to_datetime() << endl; // Outputs "2023-10-05 14:30:45.123"
            get_time_ms = original; // Restore default
            return 0;
        }

Interval Parsing
- Convert human-readable intervals to seconds for scheduling or timeouts.
Example:
        #include "tools/utils/datetime.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            try {
                time_sec five_minutes = interval_to_sec("5m");
                time_sec one_day = interval_to_sec("1d");
                cout << "5 minutes: " << five_minutes << " seconds" << endl;
                cout << "1 day: " << one_day << " seconds" << endl;
            } catch (const ERROR& e) {
                cerr << "Error: " << e.what() << endl;
            }
            return 0;
        }

Validation and Normalization
- Ensure datetime inputs are valid and standardized.
Example:
        #include "tools/utils/datetime.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            string input = "2023-10-05 14:30";
            if (is_valid_datetime(input)) {
                string normalized = normalize_datetime(input);
                cout << "Normalized: " << normalized << endl; // "2023-10-05 14:30:00.000"
            } else {
                cout << "Invalid datetime" << endl;
            }
            return 0;
        }

Best Practices
- Use datetime_to_ms() and related functions over deprecated date_parse_ms() for stricter validation.
- Handle exceptions from datetime_to_* and interval_to_sec() for invalid inputs.
- Specify local=true in formatting functions if local timezone output is needed; default is UTC.
- Test datetime strings with is_valid_datetime() before parsing to avoid exceptions where possible.

Dependencies
- Internal: tools::utils::ERROR (exception class), tools::utils::regx (regex matching), tools::utils::strings (trim).
- External: Standard C++ libraries (<thread>, <iomanip>, <unordered_map>, <chrono>).

Contributing
- Add support for more time units in interval_to_sec() (e.g., "Q" for quarters).
- Enhance is_valid_datetime() with stricter leap-second or timezone handling.
- Submit enhancements to src/tools/utils/datetime.hpp in the project repository.

------------------------------------------------------------------
tools/utils/ERROR.hpp
Error Handling Documentation

Overview
The tools::utils error handling utilities provide a set of macros and functions for creating exceptions and logging 
debug messages in C++ applications. It integrates ANSI formatting for visually distinct error and debug output, 
including file and line information for traceability. Designed for simplicity and consistency, it supports runtime 
error generation, null pointer checks, and debug logging, making it useful for development and debugging workflows.
Namespace: tools::utils

Key Components

Macros for Formatting
- FILE_LINE_ERROR_MSG: Formats an error message with file, line, and message in bold white (file) and bold red (message).
  - Definition: (ANSI_FMT_FNAME + file + ANSI_FMT_RESET ":" + to_string(line) + " - " + ANSI_FMT_ERROR + msg + ANSI_FMT_RESET)
- FILE_LINE_DEBUG_MSG: Formats a debug message with file, line, and message in bold white (file) and black (message).
  - Definition: (ANSI_FMT_FNAME + file + ANSI_FMT_RESET ":" + to_string(line) + " - " + ANSI_FMT_DEBUG + msg + ANSI_FMT_RESET)

Core Functions
- runtime_error error(const string& msg, const string& file, int line): Creates a runtime_error with a formatted message.
  - Returns: runtime_error with FILE_LINE_ERROR_MSG as the error string.
- void debug(const string& msg, const string& file, int line): Outputs a debug message to stdout with "[DEBUG]" prefix.
  - Outputs: "[DEBUG] " followed by FILE_LINE_DEBUG_MSG.

Utility Macros
- ERROR(msg): Creates a runtime_error with the given message, including current file and line; must be thrown explicitly.
  - Usage: throw ERROR("Something went wrong")
- UNIMP_THROWS: Throws an "Unimplemented" error with file and line information.
  - Usage: UNIMP_THROWS (no arguments needed)
- DEBUG(msg): Prints a debug message with the given text, including file and line.
  - Usage: DEBUG("Processing data")
- NULLCHK(p, [errmsg]): Checks if a pointer is null; throws an ERROR with a default or custom message if true.
  - Variants:
    - NULLCHK(p): Uses "nullptr" as the default error message.
    - NULLCHK(p, errmsg): Uses the provided custom error message.

Usage

1. Throwing an Error
Use ERROR macro with throw to raise an exception with file and line context.
Example:
        #include "tools/utils/ERROR.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            try {
                throw ERROR("Invalid operation");
            } catch (const runtime_error& e) {
                cerr << "Caught: " << e.what() << endl;
            }
            return 0;
        }
        // Output example: "main.cpp:10 - Invalid operation" (with ANSI formatting)

2. Marking Unimplemented Code
Use UNIMP_THROWS to indicate unfinished sections; it automatically throws the error.
Example:
        #include "tools/utils/ERROR.hpp"
        using namespace std;
        using namespace tools::utils;
        void unfinished_function() {
            UNIMP_THROWS;
        }
        int main() {
            try {
                unfinished_function();
            } catch (const runtime_error& e) {
                cerr << "Caught: " << e.what() << endl;
            }
            return 0;
        }
        // Output example: "main.cpp:15 - Unimplemented" (with ANSI formatting)

3. Logging Debug Messages
Use DEBUG to print debug information during execution.
Example:
        #include "tools/utils/ERROR.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            DEBUG("Starting program");
            return 0;
        }
        // Output example: "[DEBUG] main.cpp:10 - Starting program" (with ANSI formatting)

4. Null Pointer Checks
Use NULLCHK to validate pointers with optional custom messages; it throws automatically if null.
Example:
        #include "tools/utils/ERROR.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            int* ptr = nullptr;
            try {
                NULLCHK(ptr); // Default message
            } catch (const runtime_error& e) {
                cerr << "Caught: " << e.what() << endl;
            }
            try {
                NULLCHK(ptr, "Null pointer detected"); // Custom message
            } catch (const runtime_error& e) {
                cerr << "Caught: " << e.what() << endl;
            }
            return 0;
        }
        // Output examples:
        // "main.cpp:12 - nullptr" (with ANSI formatting)
        // "main.cpp:16 - Null pointer detected" (with ANSI formatting)

Advanced Usage

Custom Error Handling
- Combine throw ERROR with logic to provide detailed context.
Example:
        #include "tools/utils/ERROR.hpp"
        using namespace std;
        using namespace tools::utils;
        int divide(int a, int b) {
            if (b == 0) {
                throw ERROR("Division by zero");
            }
            return a / b;
        }
        int main() {
            try {
                divide(10, 0);
            } catch (const runtime_error& e) {
                cerr << "Error: " << e.what() << endl;
            }
            return 0;
        }

Conditional Debugging
- Use DEBUG within conditional blocks for selective logging.
Example:
        #include "tools/utils/ERROR.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            bool verbose = true;
            if (verbose) {
                DEBUG("Verbose mode enabled");
            }
            return 0;
        }

Best Practices
- Use throw ERROR for critical failures that should halt execution or be caught higher up.
- Reserve UNIMP_THROWS for placeholders during development; replace with proper implementations before release.
- Use DEBUG sparingly in production code to avoid cluttering output; consider a debug flag to toggle it.
- Ensure ANSI-compatible terminals for formatted output (e.g., Linux/macOS terminals, Windows Terminal); 
non-compatible terminals may show raw escape codes.
- Wrap NULLCHK around pointer dereferences to catch null pointer issues early.

Dependencies
- Internal: tools::utils::ANSI_FMT (formatting macros from "ANSI_FMT.hpp").
- External: Standard C++ libraries (<string>, <iostream>, <stdexcept>).

Contributing
- Add support for custom exception types beyond runtime_error in ERROR macro.
- Enhance DEBUG with timestamp or log level options.
- Submit enhancements to src/tools/utils/ERROR.hpp in the project repository.

------------------------------------------------------------------
tools/utils/files.hpp
File Utilities Documentation

Overview
The tools::utils file utilities provide a set of functions for interacting with the filesystem in C++, inspired by 
PHP-like functionality. Built on top of the C++17 <filesystem> library and Unix system calls, it offers methods for 
file existence checks, reading/writing files, directory management, and ownership/permission modifications. Designed 
for portability and robustness, it includes error handling options and is suitable for applications requiring 
filesystem operations.
Namespace: tools::utils

Key Components

File Existence and Type Checks
- bool file_exists(const string& path): Checks if a file or directory exists at the given path.
  - Returns: true if the path exists, false otherwise.
- bool is_dir(const string& path): Checks if the given path is an existing directory.
  - Returns: true if the path exists and is a directory, false otherwise.

File Reading and Writing
- string file_get_contents(const string& filename): Reads the entire contents of a file into a string.
  - Throws: ios_base::failure if the file cannot be opened or read.
- bool file_put_contents(const string& filename, const string& content, bool append = false, bool throws = false): 
Writes content to a file.
  - Parameters:
    - append: If true, appends to the file; if false, overwrites it.
    - throws: If true, throws an exception on failure; if false, returns false.
  - Returns: true on success, false on failure (if throws=false).
  - Throws: ios_base::failure if throws=true and the file cannot be opened or written.

Directory Management
- bool mkdir(const string& directoryPath, int permissions = 0777, bool recursive = false): Creates a directory.
  - Parameters:
    - permissions: Unix-style permissions (default: 0777); applied on Unix-like systems.
    - recursive: If true, creates parent directories as needed.
  - Returns: true if the directory is created or already exists, false on failure.

File and Directory Removal and Renaming
- bool remove(const string& path, bool throws = true): Removes a file or directory.
  - Parameters:
    - throws: If true, throws an exception on failure; if false, returns false.
  - Returns: true on success, false on failure (if throws=false).
  - Throws: ERROR if throws=true and removal fails.
- bool rename(const string& from, const string& to, bool throws = false): Renames or moves a file/directory.
  - Parameters:
    - throws: If true, throws an exception on failure; if false, returns false and logs to cerr.
  - Returns: true on success, false on failure (if throws=false).
  - Throws: ERROR if throws=true and renaming fails.

Ownership and Permissions (Unix-like Systems)
- void chown(const string& filename, const string& new_owner_username): Changes the owner of a file.
  - Throws: ERROR if the user is not found or the operation fails.
- void chgrp(const string& filename, const string& groupname): Changes the group of a file.
  - Throws: ERROR if the group is not found or the operation fails.
- void chprm(const string& filename, mode_t mode): Changes the permissions of a file.
  - Throws: ERROR if the operation fails.

Usage

1. Checking File Existence
Verify if a file or directory exists.
Example:
        #include "tools/utils/files.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            if (file_exists("example.txt")) {
                cout << "File exists" << endl;
            }
            if (is_dir("my_dir")) {
                cout << "Directory exists" << endl;
            }
            return 0;
        }

2. Reading and Writing Files
Read from or write to a file with error handling.
Example:
        #include "tools/utils/files.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            try {
                file_put_contents("test.txt", "Hello, world!");
                string content = file_get_contents("test.txt");
                cout << "File content: " << content << endl;
            } catch (const ios_base::failure& e) {
                cerr << "File error: " << e.what() << endl;
            }
            return 0;
        }

3. Creating Directories
Create a directory with optional recursion and permissions.
Example:
        #include "tools/utils/files.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            if (mkdir("new_dir/sub_dir", 0755, true)) {
                cout << "Directory created or already exists" << endl;
            } else {
                cerr << "Failed to create directory" << endl;
            }
            return 0;
        }

4. Renaming and Removing Files
Move or delete files with optional error throwing.
Example:
        #include "tools/utils/files.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            try {
                rename("test.txt", "renamed.txt", true);
                remove("renamed.txt");
                cout << "File renamed and removed" << endl;
            } catch (const runtime_error& e) {
                cerr << "Error: " << e.what() << endl;
            }
            return 0;
        }

Advanced Usage

Appending to Files
- Use file_put_contents with append=true for logging or incremental writes.
Example:
        #include "tools/utils/files.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            file_put_contents("log.txt", "First line\n", false); // Overwrite
            file_put_contents("log.txt", "Second line\n", true); // Append
            string content = file_get_contents("log.txt");
            cout << "Log content:\n" << content << endl;
            return 0;
        }

Changing Ownership and Permissions (Unix-like Systems)
- Modify file ownership and permissions on Unix platforms.
Example:
        #include "tools/utils/files.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            try {
                file_put_contents("file.txt", "Test content");
                chown("file.txt", "user1");    // Change owner
                chgrp("file.txt", "group1");   // Change group
                chprm("file.txt", 0644);       // Set permissions to rw-r--r--
                cout << "Ownership and permissions updated" << endl;
            } catch (const runtime_error& e) {
                cerr << "Error: " << e.what() << endl;
            }
            return 0;
        }

Best Practices
- Wrap calls to throwing functions (e.g., file_get_contents, chown) in try-catch blocks for robust error handling.
- Use throws=false in file_put_contents, remove, and rename for non-critical operations to avoid exceptions.
- Specify recursive=true in mkdir when creating nested directory structures.
- Check platform compatibility for chown, chgrp, and chprm, as they are Unix-specific; use #ifdef guards if needed.
- Ensure C++17 or later is used, as <filesystem> is required.

Dependencies
- Internal: tools::utils::strings (str_cut_begin), tools::utils::ERROR (exception macro).
- External: Standard C++ libraries (<iostream>, <string>, <cstring>, <fstream>, <filesystem>, <stdexcept>, <unistd.h>, 
<pwd.h>, <grp.h>, <errno.h>, <sys/stat.h>, <sys/types.h>).

Contributing
- Add support for Windows-specific ownership/permission handling (e.g., via Win32 API).
- Enhance mkdir with custom error messages on failure.
- Submit enhancements to src/tools/utils/file.hpp in the project repository.

------------------------------------------------------------------
tools/utils/io.hpp
IO Operations Documentation

Overview
The tools::utils IO operations utilities provide functions for handling input and output operations in C++ console 
applications. It includes methods for writing to stdout, reading user input, detecting keypresses, prompting for 
confirmation, and capturing output streams. Designed for interactive command-line interfaces, it uses mutexes for 
thread safety and Unix-specific terminal control for non-blocking input detection.
Namespace: tools::utils

Key Components

Output Functions
- void write(const string& output = ""): Writes a string to stdout without a newline.
  - Flushes the output immediately.
- void writeln(const string& output = ""): Writes a string to stdout with a newline.
  - Equivalent to write() followed by endl.

Input Functions
- string readln(const string& prompt = ""): Reads a line of input from stdin after displaying an optional prompt.
  - Returns: The user-entered string.
  - Thread-safe via io_readln_mtx mutex.
- bool kbhit(): Checks if a key has been pressed (non-blocking).
  - Returns: true if a key is available in the input buffer, false otherwise.
  - Thread-safe via io_kbhit_mtx mutex.
  - Note: Unix-specific; modifies terminal settings temporarily.
- bool confirm(const string& message, char def = 'y'): Prompts the user for a yes/no confirmation with a default choice.
  - Parameters:
    - message: The prompt text.
    - def: Default response ('y' or 'n', case-insensitive).
  - Returns: true for 'y', false for 'n', or the default if Enter is pressed.
  - Thread-safe via io_confirm_mtx mutex.

Output Capture Helpers
- string capture_cout(function<void()> func): Captures stdout output from a function.
  - Returns: The captured stdout as a string.
- string capture_cerr(function<void()> func): Captures stderr output from a function.
  - Returns: The captured stderr as a string.
- string capture_cout_cerr(function<void()> func): Captures both stdout and stderr (redirecting stderr to stdout).
  - Returns: The combined output as a string.

Usage

1. Writing to Console
Output text with or without newlines.
Example:
        #include "tools/utils/io.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            write("Hello, ");
            writeln("world!");
            // Output: "Hello, world!" (on one line)
            return 0;
        }

2. Reading User Input
Prompt for and read a line of input.
Example:
        #include "tools/utils/io.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            string name = readln("Enter your name: ");
            writeln("Hello, " + name);
            return 0;
        }

3. Detecting Keypresses
Check for user input without blocking.
Example:
        #include "tools/utils/io.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            writeln("Press any key to continue...");
            while (!kbhit()) {
                // Wait for input
            }
            writeln("Key pressed!");
            return 0;
        }

4. Confirmation Prompt
Ask for yes/no confirmation with a default option.
Example:
        #include "tools/utils/io.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            bool proceed = confirm("Do you want to proceed?", 'n');
            if (proceed) {
                writeln("Proceeding...");
            } else {
                writeln("Aborted.");
            }
            return 0;
        }

Advanced Usage

Capturing Output
- Capture stdout, stderr, or both for testing or logging.
Example:
        #include "tools/utils/io.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            string output = capture_cout([]() {
                writeln("This goes to stdout");
            });
            string error = capture_cerr([]() {
                cerr << "This goes to stderr" << endl;
            });
            string combined = capture_cout_cerr([]() {
                writeln("To stdout");
                cerr << "To stderr" << endl;
            });
            writeln("Captured stdout: " + output);
            writeln("Captured stderr: " + error);
            writeln("Combined: " + combined);
            return 0;
        }

Thread-Safe Input
- Use readln() or confirm() in multi-threaded contexts safely.
Example:
        #include "tools/utils/io.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            thread t1([]() {
                string input = readln("Thread 1 input: ");
                writeln("Thread 1 got: " + input);
            });
            thread t2([]() {
                string input = readln("Thread 2 input: ");
                writeln("Thread 2 got: " + input);
            });
            t1.join();
            t2.join();
            return 0;
        }

Best Practices
- Use writeln() for complete messages to ensure line breaks; use write() for partial output or custom formatting.
- Wrap kbhit() in loops for polling; note it’s Unix-specific and unavailable on Windows without alternatives.
- Set appropriate default values in confirm() to guide user behavior (e.g., 'n' for destructive actions).
- Use capture_* functions for testing or redirecting output; avoid in performance-critical sections due to buffer 
overhead.
- Ensure thread safety by relying on the provided mutexes; avoid concurrent unprotected cin/cout access.

Dependencies
- External: Standard C++ libraries (<iostream>, <string>, <limits>, <atomic>, <mutex>, <sstream>, <functional>, 
<fcntl.h>, <unistd.h>, <termios.h>).

Contributing
- Add Windows-compatible kbhit() using _kbhit() from <conio.h> with #ifdef guards.
- Enhance confirm() with timeout or additional input options (e.g., 'q' to quit).
- Submit enhancements to src/tools/utils/io.hpp in the project repository.

------------------------------------------------------------------
tools/utils/JSON.hpp
JSON Utilities Documentation

Overview
The tools::utils JSON utilities provide a comprehensive set of functions and a class for manipulating JSON data in 
C++. Built on the nlohmann/json library, it includes tools for preprocessing JSON strings (removing comments and 
trailing commas), validating JSON, retrieving typed values using selectors, and managing JSON objects via the JSON 
class. Designed for robustness and flexibility, it supports jq-style selectors and integrates error handling via the 
ERROR macro.
Namespace: tools::utils

Key Components

Preprocessing Functions
- string json_remove_comments(const string& json): Removes single-line (//) and multi-line (/* */) comments from a JSON string.
  - Preserves content within string literals.
  - Returns: The JSON string with comments removed.
- string json_fix(string json): Fixes JSON by removing comments and trailing commas.
  - Returns: A cleaned JSON string suitable for parsing.

JSON Validation and Error Handling
- bool is_valid_json(string jstring): Checks if a JSON string is valid.
  - Sets json_last_error on failure.
  - Returns: true if valid, false otherwise.
- string get_json_error(string jstring): Retrieves the last parse error for a JSON string.
  - Returns: Empty string if valid, error message if invalid.

Type Enum and Utilities
- enum json_type: Defines possible JSON value types.
  - Values: JSON_TYPE_UNDEFINED, JSON_TYPE_NULL, JSON_TYPE_STRING, JSON_TYPE_INTEGER, JSON_TYPE_REAL, 
JSON_TYPE_BOOLEAN, JSON_TYPE_ARRAY, JSON_TYPE_OBJECT
- string json_type_to_string(json_type type): Converts a json_type to a human-readable string.
  - Throws: ERROR for invalid types.

Selector-Based Retrieval
- json::json_pointer _json_selector(string jselector): Converts a jq-style selector (e.g., ".key[0]") to a JSON pointer.
  - Throws: ERROR for invalid selectors (e.g., empty parts, non-numeric array indices, mismatched brackets).
- json_type get_json_value_type(string jstring, string jselector): Gets the type of a value at a selector.
  - Returns: JSON_TYPE_UNDEFINED for invalid JSON or undefined paths.
- string json_get_string(string jstring, string jselector): Retrieves a string value.
  - Throws: ERROR if type mismatch or retrieval fails.
- int json_get_int(string jstring, string jselector): Retrieves an integer value.
  - Throws: ERROR if type mismatch or retrieval fails.
- double json_get_double(string jstring, string jselector): Retrieves a double value.
  - Throws: ERROR if type mismatch or retrieval fails.
- bool json_get_bool(string jstring, string jselector): Retrieves a boolean value.
  - Throws: ERROR if type mismatch or retrieval fails.
- string json_get_array(string jstring, string jselector): Retrieves an array as a JSON string.
  - Throws: ERROR if type mismatch or retrieval fails.
- string json_get_object(string jstring, string jselector): Retrieves an object as a JSON string.
  - Throws: ERROR if type mismatch or retrieval fails.

JSON Class
- class JSON: Manages a JSON object with methods for validation, retrieval, and modification.
  - Constructors:
    - JSON(string jstring = "{}"): Parses a JSON string (defaults to empty object if empty).
    - JSON(const json& j): Initializes from an nlohmann::json object.
    - JSON(const char* j): Initializes from a C-string.
  - Destructor: ~JSON(): Frees error string if set.
  - Methods:
    - json get_json() const: Returns the underlying nlohmann::json object.
    - bool isValid(string* error = nullptr): Checks if the JSON is valid; optionally sets error string.
    - string dump(int indent = -1, char indent_char = ' ') const: Serializes the JSON to a string.
    - bool isDefined(string jselector) const: Checks if a selector exists (alias: has()).
    - bool isNull(string jselector): Checks if a value is null.
    - bool isArray(string jselector): Checks if a value is an array.
    - bool isObject(string jselector): Checks if a value is an object.
    - template<typename T> T get(string jselector) const: Retrieves a value of type T.
    - template<typename T> void set(string jselector, T value): Sets a value at a selector.
  - Throws: ERROR for parse errors, type mismatches, or invalid selectors.

Usage

1. Preprocessing JSON
Remove comments and fix trailing commas.
Example:
        #include "tools/utils/JSON.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            string raw = R"({"key": "value", // comment
                            "array": [1, 2, 3,]})";
            string clean = json_fix(raw);
            cout << "Cleaned JSON: " << clean << endl;
            return 0;
        }

2. Validating JSON
Check if a JSON string is valid and retrieve errors.
Example:
        #include "tools/utils/JSON.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            string valid = "{\"key\": \"value\"}";
            string invalid = "{";
            if (is_valid_json(valid)) {
                cout << "Valid JSON" << endl;
            }
            string err = get_json_error(invalid);
            if (!err.empty()) {
                cout << "Error: " << err << endl;
            }
            return 0;
        }

3. Retrieving Typed Values
Get values from a JSON string using selectors.
Example:
        #include "tools/utils/JSON.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            string jstring = R"({"name": "Alice", "age": 30, "active": true})";
            try {
                string name = json_get_string(jstring, ".name");
                int age = json_get_int(jstring, ".age");
                bool active = json_get_bool(jstring, ".active");
                cout << name << ", " << age << ", " << (active ? "true" : "false") << endl;
            } catch (const runtime_error& e) {
                cerr << "Error: " << e.what() << endl;
            }
            return 0;
        }

4. Using the JSON Class
Manage JSON objects with the JSON class.
Example:
        #include "tools/utils/JSON.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            JSON json(R"({"user": {"name": "Bob", "scores": [85, 90]}})");
            if (json.isValid()) {
                cout << "Dump: " << json.dump(2) << endl;
                if (json.isDefined(".user.name")) {
                    string name = json.get<string>(".user.name");
                    cout << "Name: " << name << endl;
                }
                json.set(".user.age", 25);
                cout << "Updated: " << json.dump(2) << endl;
            } else {
                cerr << "Invalid JSON" << endl;
            }
            return 0;
        }

Advanced Usage

Nested Selectors
- Use jq-style selectors for nested data access.
Example:
        #include "tools/utils/JSON.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            string jstring = R"({"data": {"list": [1, {"value": 42}]}})";
            try {
                int value = json_get_int(jstring, ".data.list[1].value");
                cout << "Nested value: " << value << endl;
            } catch (const runtime_error& e) {
                cerr << "Error: " << e.what() << endl;
            }
            return 0;
        }

Type Checking
- Verify types before retrieval to avoid exceptions.
Example:
        #include "tools/utils/JSON.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            string jstring = R"({"key": "value"})";
            json_type type = get_json_value_type(jstring, ".key");
            cout << "Type: " << json_type_to_string(type) << endl;
            return 0;
        }

Best Practices
- Use json_fix() on raw JSON input to handle comments and trailing commas before parsing.
- Wrap retrieval functions (json_get_*) in try-catch blocks to handle type mismatches or invalid selectors.
- Prefer the JSON class for repeated operations on the same JSON data to avoid reparsing.
- Validate selectors with is_valid_json() and get_json_value_type() before accessing to minimize errors.
- Use meaningful selector paths (e.g., ".user.name" instead of "user.name") for clarity, though both are supported.

Dependencies
- Internal: tools::utils::ERROR (exception macro), tools::utils::strings (explode, implode, str_contains).
- External: Standard C++ libraries (<string>, <vector>, <map>, <regex>), nlohmann/json 
(../../../libs/nlohmann/json/single_include/nlohmann/json.hpp).

Contributing
- Enhance json_fix() to handle additional edge cases (e.g., malformed comments).
- Add support for more selector syntax (e.g., filters like jq’s .[]).
- Submit enhancements to src/tools/utils/json.hpp in the project repository.

------------------------------------------------------------------
tools/utils/Logger.hpp
Logger Documentation

Overview
The tools::utils Logger provides a flexible, thread-safe logging system for C++ applications. It supports multiple log 
levels (DEBUG, INFO, WARNING, ERROR), asynchronous logging via a background thread, and output to both console and 
file. Key features include customizable log formatting, minimum log level filtering, and convenience macros that 
automatically include file and line information. Designed for ease of use and performance, it ensures non-blocking 
logging in multi-threaded environments.
Namespace: tools::utils

Key Components

Logger Class
- class Logger: Manages logging operations with thread-safe, asynchronous capabilities.
  - Enum: Level { DEBUG, INFO, WARNING, ERROR, NONE }
    - DEBUG: Highest verbosity for detailed debugging.
    - INFO: General information.
    - WARNING: Potential issues.
    - ERROR: Critical errors.
    - NONE: Disables logging (highest value).
  - Type: LogFormatter = function<string(Level, const string&, const string&)>
    - Defines a custom formatter for log messages.
  - Constructors:
    - Logger(const string& name, const string& filename = "", LogFormatter customFormatter = nullptr): Initializes with a name, optional file, and optional formatter.
  - Destructor: ~Logger(): Stops the logging thread and closes the file if open.
  - Deleted Copy Operations: Copy constructor and assignment operator are disabled.
  - Move Operations: Supports move constructor and move assignment for ownership transfer.
  - Methods:
    - void setMinLogLevel(Level level): Sets the minimum level for logging.
    - void log(Level level, const string& message): Logs a message if above minLogLevel (virtual).
    - void debug(const string& message): Logs at DEBUG level (alias: dbg).
    - void info(const string& message): Logs at INFO level (alias: nfo).
    - void warning(const string& message): Logs at WARNING level (alias: warn).
    - void error(const string& message): Logs at ERROR level (alias: err).

Convenience Macros
- LOG_DEBUG(logger, message): Logs at DEBUG level with file and line.
- LOG_INFO(logger, message): Logs at INFO level with file and line.
- LOG_WARNING(logger, message): Logs at WARNING level with file and line.
- LOG_ERROR(logger, message): Logs at ERROR level with file and line.

Usage

1. Basic Console Logging
Log messages to the console with default formatting.
Example:
        #include "tools/utils/Logger.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            Logger logger("MyApp");
            logger.info("Starting application");
            LOG_DEBUG(logger, "Debugging enabled");
            logger.error("Something went wrong");
            this_thread::sleep_for(chrono::milliseconds(100)); // Allow logs to process
            return 0;
        }
        // Output example: "2025-03-06 12:00:00 [MyApp] INFO: Starting application"
        //                 "2025-03-06 12:00:00 [MyApp] DEBUG: main.cpp:10 Debugging enabled"
        //                 "2025-03-06 12:00:00 [MyApp] ERROR: Something went wrong"

2. File Logging
Log messages to a file instead of the console.
Example:
        #include "tools/utils/Logger.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            Logger logger("MyApp", "app.log");
            logger.info("Log to file");
            this_thread::sleep_for(chrono::milliseconds(100)); // Allow logs to process
            return 0;
        }
        // app.log content example: "2025-03-06 12:00:00 [MyApp] INFO: Log to file"

3. Filtering Log Levels
Set a minimum log level to filter messages.
Example:
        #include "tools/utils/Logger.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            Logger logger("MyApp");
            logger.setMinLogLevel(Logger::Level::WARNING);
            logger.info("This won't appear");
            LOG_WARNING(logger, "This will appear");
            this_thread::sleep_for(chrono::milliseconds(100)); // Allow logs to process
            return 0;
        }
        // Output example: "2025-03-06 12:00:00 [MyApp] WARNING: main.cpp:11 This will appear"

Advanced Usage

Custom Log Formatting
- Define a custom formatter for log messages.
Example:
        #include "tools/utils/Logger.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            auto customFormat = [](Logger::Level level, const string& name, const string& msg) {
                return "[" + name + "] " + msg;
            };
            Logger logger("MyApp", "", customFormat);
            logger.info("Custom format message");
            this_thread::sleep_for(chrono::milliseconds(100)); // Allow logs to process
            return 0;
        }
        // Output example: "[MyApp] Custom format message"

Thread-Safe Logging
- Use in multi-threaded applications without conflicts.
Example:
        #include "tools/utils/Logger.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            Logger logger("MyApp");
            thread t1([&logger]() { LOG_INFO(logger, "Thread 1 logging"); });
            thread t2([&logger]() { LOG_INFO(logger, "Thread 2 logging"); });
            t1.join();
            t2.join();
            this_thread::sleep_for(chrono::milliseconds(100)); // Allow logs to process
            return 0;
        }

Best Practices
- Use LOG_* macros for detailed debugging with file/line info; use direct methods (info, error) for simpler logs.
- Set minLogLevel to WARNING or ERROR in production to reduce verbosity.
- Provide a filename for persistent logs; omit it for console-only output.
- Use custom formatters to tailor log appearance to your needs.
- Ensure sufficient sleep or synchronization in short-lived programs to allow the background thread to process logs 
before exit.
- Avoid logging empty messages, as they are ignored by design.

Dependencies
- Internal: tools::utils::files (is_dir, mkdir).
- External: Standard C++ libraries (<iostream>, <fstream>, <string>, <chrono>, <iomanip>, <sstream>, <mutex>, 
<queue>, <thread>, <condition_variable>, <functional>).

Contributing
- Add support for log rotation (e.g., size-based file switching).
- Enhance formatter with color output using ANSI codes.
- Submit enhancements to src/tools/utils/Logger.hpp in the project repository.

------------------------------------------------------------------
tools/utils/regx.hpp
Regular Expression Utilities Documentation

Overview
The tools::utils regular expression utilities provide a set of functions for matching and replacing patterns in 
strings using the C++ <regex> library. Designed for simplicity and flexibility, these functions support single and 
multiple matches, capture groups, and string replacement, with optional regex flags for customization (e.g., 
case-insensitive matching). Built-in error handling ensures robustness for invalid patterns or edge cases.
Namespace: tools::utils

Key Components

Matching Functions
- int regx_match(const string& pattern, const string& str, vector<string>* matches = nullptr, syntax_option_type flags = ECMAScript):
Matches the first occurrence of a pattern in a string.
  - Parameters:
    - pattern: The regex pattern (ECMAScript syntax).
    - str: The input string to search.
    - matches: Optional pointer to a vector for storing the full match and capture groups.
    - flags: Regex flags (default: ECMAScript; e.g., icase for case-insensitive).
  - Returns: 1 if a match is found, 0 otherwise.
  - Behavior: Populates matches with the full match followed by capture groups if provided.
- int regx_match_all(const string& pattern, const string& str, vector<string>* matches = nullptr, syntax_option_type flags = ECMAScript):
Matches all occurrences of a pattern in a string.
  - Parameters: Same as regx_match.
  - Returns: Number of matches found.
  - Behavior: Populates matches with full matches and their capture groups (if any) in sequence; returns 0 for invalid patterns.

Replacement Functions
- string regx_replace(const string& pattern, const string& str, const string& replace):
Replaces the first occurrence of a pattern in a string.
  - Parameters:
    - pattern: The regex pattern.
    - str: The input string.
    - replace: The replacement string.
  - Returns: The modified string with the first match replaced.
  - Throws: ERROR if the pattern is empty.
- string regx_replace_all(const string& pattern, const string& str, const string& replace):
Replaces all occurrences of a pattern in a string.
  - Parameters: Same as regx_replace.
  - Returns: The modified string with all matches replaced.
  - Throws: ERROR if the pattern is empty.

Usage

1. Single Match
Find the first match and optionally capture groups.
Example:
        #include "tools/utils/regx.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            string str = "Hello, world!";
            vector<string> matches;
            if (regx_match("(\\w+), (\\w+)", str, &matches)) {
                cout << "Full match: " << matches[0] << endl;
                cout << "Group 1: " << matches[1] << endl;
                cout << "Group 2: " << matches[2] << endl;
            }
            return 0;
        }
        // Output: Full match: Hello, world
        //         Group 1: Hello
        //         Group 2: world

2. Multiple Matches
Find all matches with capture groups.
Example:
        #include "tools/utils/regx.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            string str = "Numbers: 123 456 789";
            vector<string> matches;
            int count = regx_match_all("\\d+", str, &matches);
            cout << "Found " << count << " matches:" << endl;
            for (const auto& match : matches) {
                cout << match << endl;
            }
            return 0;
        }
        // Output: Found 3 matches:
        //         123
        //         456
        //         789

3. Replace First Occurrence
Replace only the first match of a pattern.
Example:
        #include "tools/utils/regx.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            string str = "apple apple apple";
            string result = regx_replace("apple", str, "fruit");
            cout << "Result: " << result << endl;
            return 0;
        }
        // Output: Result: fruit apple apple

4. Replace All Occurrences
Replace all matches of a pattern.
Example:
        #include "tools/utils/regx.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            string str = "apple apple apple";
            string result = regx_replace_all("apple", str, "fruit");
            cout << "Result: " << result << endl;
            return 0;
        }
        // Output: Result: fruit fruit fruit

Advanced Usage

Case-Insensitive Matching
- Use regex_constants::icase for case-insensitive searches.
Example:
        #include "tools/utils/regx.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            string str = "HELLO world";
            vector<string> matches;
            int count = regx_match_all("hello", str, &matches, regex_constants::icase);
            cout << "Found " << count << " matches:" << endl;
            for (const auto& match : matches) {
                cout << match << endl;
            }
            return 0;
        }
        // Output: Found 1 matches:
        //         HELLO

Special Characters and Capture Groups
- Handle complex patterns with capture groups.
Example:
        #include "tools/utils/regx.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            string str = "Phone: 123-456-7890, 098-765-4321";
            vector<string> matches;
            int count = regx_match_all("(\\d{3})-(\\d{3})-(\\d{4})", str, &matches);
            cout << "Found " << count << " phone numbers:" << endl;
            for (size_t i = 0; i < matches.size(); i += 4) {
                cout << "Number: " << matches[i] << " (Area: " << matches[i+1] << ")" << endl;
            }
            return 0;
        }
        // Output: Found 2 phone numbers:
        //         Number: 123-456-7890 (Area: 123)
        //         Number: 098-765-4321 (Area: 098)

Best Practices
- Use regx_match for quick single-match checks; use regx_match_all for exhaustive searches.
- Provide a matches vector when capture groups or all matches are needed; leave nullptr for simple presence checks.
- Wrap regx_replace and regx_replace_all in try-catch blocks to handle empty pattern exceptions.
- Use regex flags (e.g., icase) to customize matching behavior; ECMAScript is the default syntax.
- Test patterns for validity, as invalid ones return 0 matches in regx_match_all but may throw in other contexts.

Dependencies
- Internal: tools::utils::ERROR (exception macro).
- External: Standard C++ library (<regex>).

Contributing
- Add support for additional regex flags (e.g., multiline, dotall).
- Enhance error reporting for invalid patterns beyond returning 0 or throwing.
- Submit enhancements to src/tools/utils/regx.hpp in the project repository.

------------------------------------------------------------------
tools/utils/RingBuffer.hpp
RingBuffer Documentation

Overview
The tools::utils RingBuffer is a thread-safe, generic circular buffer implementation in C++ for managing a fixed-size 
queue of elements. It supports configurable write policies (Reject, Rotate, Reset), blocking and non-blocking reads, 
and features like peeking, clearing, and drop callbacks. Designed for producer-consumer scenarios, it ensures 
efficient data handling with atomic size tracking and mutex-based synchronization.
Namespace: tools::utils

Key Components

RingBuffer Class
- template<typename T> class RingBuffer: A circular buffer for type T.
  - Enum: WritePolicy { Reject, Rotate, Reset }
    - Reject: Rejects new writes if insufficient space.
    - Rotate: Overwrites oldest items to fit new data (rolling window).
    - Reset: Discards all unread data before writing new data.
  - Constructor: RingBuffer(size_t capacity, WritePolicy policy): Initializes with capacity and policy.
    - Throws: invalid_argument if capacity < 1.
  - Methods:
    - bool write(const T* data, size_t count): Writes count items; returns false if rejected.
    - bool write_one(const T& item): Writes a single item; convenience wrapper for write.
    - size_t try_write_all(const T* data, size_t count): Writes all items or none; returns unwritten count (0 if all written).
    - size_t read(T* dest, size_t maxCount, bool blocking = false, int timeoutMs = 1000): Reads up to maxCount items; blocks if specified.
    - bool read_one(T& item): Reads one item; returns true if successful.
    - bool peek_one(T& item): Peeks at the next item without removing it.
    - size_t available() const: Returns the current number of items.
    - size_t remaining_capacity() const: Returns available space.
    - void clear(): Empties the buffer.
    - using DropCallback = function<void(size_t count)>: Callback type for dropped items.
    - void set_drop_callback(DropCallback callback): Sets a callback for dropped items (Rotate policy).

Usage

1. Basic Read/Write with Reject Policy
Write and read data with rejection on overflow.
Example:
        #include "tools/utils/RingBuffer.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            RingBuffer<int> rb(3, RingBuffer<int>::WritePolicy::Reject);
            int data[] = {1, 2, 3};
            bool success = rb.write(data, 3);
            cout << "Write success: " << success << endl;
            int more[] = {4};
            success = rb.write(more, 1); // Rejected
            cout << "Write more success: " << success << endl;

            int readData[3];
            size_t count = rb.read(readData, 3);
            for (size_t i = 0; i < count; i++) {
                cout << readData[i] << " ";
            }
            cout << endl;
            return 0;
        }
        // Output: Write success: 1
        //         Write more success: 0
        //         1 2 3

2. Rotate Policy with Overwrite
Overwrite oldest data when full.
Example:
        #include "tools/utils/RingBuffer.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            RingBuffer<int> rb(3, RingBuffer<int>::WritePolicy::Rotate);
            int data1[] = {1, 2, 3};
            rb.write(data1, 3);
            int data2[] = {4, 5};
            rb.write(data2, 2); // Overwrites 1, 2

            int readData[3];
            size_t count = rb.read(readData, 3);
            for (size_t i = 0; i < count; i++) {
                cout << readData[i] << " ";
            }
            cout << endl;
            return 0;
        }
        // Output: 3 4 5

3. Reset Policy with Full Reset
Discard all data on overflow.
Example:
        #include "tools/utils/RingBuffer.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            RingBuffer<int> rb(3, RingBuffer<int>::WritePolicy::Reset);
            int data1[] = {1, 2};
            rb.write(data1, 2);
            int data2[] = {3, 4, 5};
            rb.write(data2, 3); // Resets, then writes 3, 4, 5

            int readData[3];
            size_t count = rb.read(readData, 3);
            for (size_t i = 0; i < count; i++) {
                cout << readData[i] << " ";
            }
            cout << endl;
            return 0;
        }
        // Output: 3 4 5

Advanced Usage

Blocking Read with Timeout
- Use blocking read to wait for data.
Example:
        #include "tools/utils/RingBuffer.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            RingBuffer<int> rb(5, RingBuffer<int>::WritePolicy::Reject);
            thread writer([&rb]() {
                this_thread::sleep_for(chrono::milliseconds(100));
                rb.write_one(42);
            });

            int data;
            size_t count = rb.read(&data, 1, true, 1000);
            cout << "Read: " << data << endl;
            writer.join();
            return 0;
        }
        // Output: Read: 42

Drop Callback with Rotate Policy
- Track dropped items during overwrite.
Example:
        #include "tools/utils/RingBuffer.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            RingBuffer<int> rb(3, RingBuffer<int>::WritePolicy::Rotate);
            size_t dropped = 0;
            rb.set_drop_callback([&dropped](size_t count) { dropped = count; });

            int data1[] = {1, 2, 3};
            rb.write(data1, 3);
            int data2[] = {4, 5};
            rb.write(data2, 2); // Drops 2 items

            cout << "Dropped: " << dropped << endl;
            int readData[3];
            rb.read(readData, 3);
            for (int i = 0; i < 3; i++) {
                cout << readData[i] << " ";
            }
            cout << endl;
            return 0;
        }
        // Output: Dropped: 2
        //         3 4 5

Thread-Safe Producer-Consumer
- Use in multi-threaded scenarios.
Example:
        #include "tools/utils/RingBuffer.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            RingBuffer<int> rb(10, RingBuffer<int>::WritePolicy::Reject);
            thread producer([&rb]() {
                for (int i = 0; i < 5; i++) {
                    rb.write_one(i);
                    this_thread::sleep_for(chrono::milliseconds(10));
                }
            });
            thread consumer([&rb]() {
                int sum = 0;
                for (int i = 0; i < 5; i++) {
                    int data;
                    rb.read_one(data);
                    sum += data;
                }
                cout << "Sum: " << sum << endl;
            });
            producer.join();
            consumer.join();
            return 0;
        }
        // Output: Sum: 10 (0 + 1 + 2 + 3 + 4)

Best Practices
- Choose WritePolicy based on needs: Reject for strict limits, Rotate for continuous data flow, Reset for fresh starts.
- Use write_one and read_one for single-item operations; try_write_all for bulk writes with feedback.
- Set blocking reads with timeouts in consumer threads to wait for data gracefully.
- Monitor available() and remaining_capacity() to manage buffer state.
- Use set_drop_callback with Rotate policy to log or handle dropped data.
- Ensure proper synchronization in short-lived programs (e.g., join threads) to avoid data loss on exit.

Dependencies
- External: Standard C++ libraries (<mutex>, <condition_variable>, <vector>, <atomic>, <stdexcept>, <algorithm>, 
<chrono>, <thread>).

Contributing
- Add support for resizing the buffer dynamically.
- Enhance drop callback with item-specific information.
- Submit enhancements to src/tools/utils/RingBuffer.hpp in the project repository.

------------------------------------------------------------------
tools/utils/Rotary.hpp
Rotary Animation Documentation

Overview
The tools::utils::Rotary class provides a simple way to display terminal animations, such as spinners or progress 
indicators, for long-running processes. It allows customizing animation frames, updating the display dynamically, 
and signaling completion with a final message.

Namespace: tools::utils

Key Components

RotaryFrames Class
- Purpose: Manages a sequence of frames for an animation.
- Constructor:
  - RotaryFrames(const vector<string>& frames, size_t speed_divider)
  - Parameters:
    - frames: A list of strings representing animation frames.
    - speed_divider: Controls the speed of frame updates.
  - Throws: invalid_argument if frames are empty.
- Methods:
  - string getNextFrame()
    - Returns the next frame in the sequence, cycling through frames based on speed_divider.

Rotary Class
- Purpose: Controls and updates terminal animations.
- Methods:
  - Rotary()
    - Initializes with default animations.
  - void clearAnims()
    - Removes all existing animations.
  - void addAnim(const RotaryFrames& anim)
    - Adds a new animation sequence.
  - void tick()
    - Advances and displays the next frame of all active animations.
  - void done(const string& message = "Done!")
    - Displays a final message and stops the animation.

Usage

1. Basic Spinner
Display a simple progress spinner.
Example:
        #include "tools/utils/Rotary.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            Rotary rotary;
            for (int i = 0; i < 50; ++i) {
                rotary.tick();
                this_thread::sleep_for(chrono::milliseconds(100));
            }
            rotary.done("Processing Complete!");
            return 0;
        }

2. Custom Animation
Define a custom animation sequence.
Example:
        #include "tools/utils/Rotary.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            Rotary rotary;
            rotary.clearAnims();
            rotary.addAnim(RotaryFrames({ "◐", "◓", "◑", "◒" }, 2)); // Custom spinner
            for (int i = 0; i < 100; ++i) {
                rotary.tick();
                this_thread::sleep_for(chrono::milliseconds(50));
            }
            rotary.done("Finished!");
            return 0;
        }

Best Practices
- Call tick() frequently to update the animation smoothly.
- Use clearAnims() before adding custom animations to remove defaults.
- Choose an appropriate speed_divider to control animation speed.
- Call done() at the end to properly signal completion.

Dependencies
- Internal: None beyond standard C++ libraries.
- External: Requires a terminal that supports overwriting text output.

Contributing
- Extend support for multi-line animations.
- Improve support for asynchronous animations.
- Submit enhancements to src/tools/utils/Rotary.hpp in the project repository.

------------------------------------------------------------------
tools/utils/strings.hpp
String Utilities Documentation

Overview
The tools::utils string utilities provide a comprehensive set of functions 
for manipulating and processing strings in C++. 
These utilities include functions for splitting and joining strings, escaping special characters, formatting strings, 
and performing various string operations such as trimming, replacing, and checking for substrings. 
Designed for flexibility and ease of use, these functions are suitable 
for a wide range of string manipulation tasks in C++ applications.
Namespace: tools::utils

Key Components

String Splitting and Joining
- vector<string> explode(const string& delimiter, const string& str): 
Splits a string into a vector of substrings based on a specified delimiter.
  - Throws: ERROR if the delimiter is empty.
- string implode(const string& delimiter, const vector<string>& elements): 
Joins a vector of strings into a single string with a specified delimiter.

String Escaping and Quoting
- string escape(const string& input, const string& chars = "\\$\"'`", const string& esc = "\\"): 
Escapes specified characters in a string.
- string quote_cmd(const string& input): Quotes a string for use in command-line arguments, escaping special characters.

String Trimming and Formatting
- string trim(const string& str): Removes leading and trailing whitespace from a string.
- string str_cut_begin(const string& s, size_t maxch = 300, const string& prepend = "..."): 
Truncates a string from the beginning, prepending a specified string if truncation occurs.
- string str_cut_end(const string& s, size_t maxch = 300, const string& append = "..."): 
Truncates a string from the end, appending a specified string if truncation occurs.
- pair<string, string> str_cut_ratio(const string& str, double ratio = 0.5): 
Splits a string into two parts based on a specified ratio.

String Replacement
- string str_replace(const map<string, string>& v, const string& s): 
Replaces multiple substrings in a string based on a map of replacements.
  - Throws: ERROR if any replacement key is empty.
- string str_replace(const string& from, const string& to, const string& subject): 
Replaces a single substring in a string.
  - Throws: ERROR if the substring to replace is empty.
- string tpl_replace(const map<string, string>& replacements, const string& template_str, 
const string& placeholder_ptrn = "\\{\\{[^}]+\\}\\}"): 
Replaces placeholders in a template string with specified values.
  - Throws: ERROR if a placeholder does not match the expected pattern or if a replacement value is missing.

String Validation and Conversion
- bool is_numeric(const string& s): Checks if a string represents a valid numeric value.
- bool is_integer(const string& s): Checks if a string represents a valid integer.
- bool is_int(const string& s): Alias for is_integer.
- template <typename T> T parse(const string& str): Parses a string into a numeric type.
  - Throws: ERROR if the string cannot be parsed.
- string set_precision(double number, int precision): Formats a double value to a specified precision.
  - Throws: ERROR if the precision is negative.
- string set_precision(const string& numberStr, int precision): Formats a numeric string to a specified precision.
  - Throws: ERROR if the input string is not numeric.

String Case Conversion
- string strtolower(const string& s): Converts a string to lowercase.
- string strtoupper(const string& s): Converts a string to uppercase.

String Comparison and Substring Checks
- bool str_contains(const string& str, const string& substring): Checks if a string contains a specified substring.
- bool str_starts_with(const string& str, const string& prefix): Checks if a string starts with a specified prefix.
- bool str_ends_with(const string& str, const string& suffix): Checks if a string ends with a specified suffix.

String Difference Calculation
- vector<str_diff_t> str_get_diffs(const string& s1, const string& s2): Computes the differences between two strings.
- void str_show_diff(const str_diff_t& diff): Displays the differences between two strings.
- vector<str_diff_t> str_diffs_show(const string& s1, const string& s2): 
Computes and displays the differences between two strings.

Usage

1. Splitting and Joining Strings
Split a string by a delimiter and join a vector of strings.
Example:
        #include "tools/utils/strings.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            vector<string> parts = explode(",", "a,b,c");
            string joined = implode("-", parts);
            cout << "Joined: " << joined << endl; // Output: "Joined: a-b-c"
            return 0;
        }

2. Escaping and Quoting Strings
Escape special characters and quote a string for command-line usage.
Example:
        #include "tools/utils/strings.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            string escaped = escape("hello$world\\", "$\\");
            string quoted = quote_cmd("hello\"world");
            cout << "Escaped: " << escaped << endl; // Output: "Escaped: hello\$world\\"
            cout << "Quoted: " << quoted << endl; // Output: "Quoted: \"hello\\\"world\""
            return 0;
        }

3. Trimming and Formatting Strings
Trim whitespace and truncate strings.
Example:
        #include "tools/utils/strings.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            string trimmed = trim("   hello world   ");
            string truncated = str_cut_begin("This is a long string", 10);
            cout << "Trimmed: " << trimmed << endl; // Output: "Trimmed: hello world"
            cout << "Truncated: " << truncated << endl; // Output: "Truncated: ...string"
            return 0;
        }

4. Replacing Substrings
Replace substrings in a string.
Example:
        #include "tools/utils/strings.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            string replaced = str_replace("hello", "hi", "hello world");
            cout << "Replaced: " << replaced << endl; // Output: "Replaced: hi world"
            return 0;
        }

5. Validating and Converting Strings
Check if a string is numeric and parse it.
Example:
        #include "tools/utils/strings.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            bool isNum = is_numeric("123.45");
            int num = parse<int>("42");
            cout << "Is numeric: " << isNum << endl; // Output: "Is numeric: 1"
            cout << "Parsed number: " << num << endl; // Output: "Parsed number: 42"
            return 0;
        }

6. Case Conversion
Convert strings to lowercase or uppercase.
Example:
        #include "tools/utils/strings.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            string lower = strtolower("Hello World");
            string upper = strtoupper("Hello World");
            cout << "Lowercase: " << lower << endl; // Output: "Lowercase: hello world"
            cout << "Uppercase: " << upper << endl; // Output: "Uppercase: HELLO WORLD"
            return 0;
        }

7. String Comparison and Substring Checks
Check if a string contains a substring or starts/ends with a specific prefix/suffix.
Example:
        #include "tools/utils/strings.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            bool contains = str_contains("hello world", "world");
            bool startsWith = str_starts_with("hello world", "hello");
            bool endsWith = str_ends_with("hello world", "world");
            cout << "Contains: " << contains << endl; // Output: "Contains: 1"
            cout << "Starts with: " << startsWith << endl; // Output: "Starts with: 1"
            cout << "Ends with: " << endsWith << endl; // Output: "Ends with: 1"
            return 0;
        }

8. String Difference Calculation
Compute and display differences between two strings.
Example:
        #include "tools/utils/strings.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            vector<str_diff_t> diffs = str_diffs_show("hello world", "hello there");
            return 0;
        }

Best Practices
- Use explode and implode for splitting and joining strings with delimiters.
- Use escape and quote_cmd for handling strings in command-line contexts.
- Use trim to remove unnecessary whitespace from strings.
- Use str_replace and tpl_replace for replacing substrings and placeholders in strings.
- Use is_numeric and parse for validating and converting strings to numeric types.
- Use strtolower and strtoupper for consistent case conversion.
- Use str_contains, str_starts_with, and str_ends_with for substring checks.
- Use str_get_diffs and str_diffs_show for comparing strings and displaying differences.

Dependencies
- Internal: tools::utils::ERROR (exception handling), tools::utils::regx (regular expression utilities).
- External: Standard C++ libraries (<string>, <vector>, <map>, <iomanip>, <sstream>, <algorithm>, <stdexcept>, <type_traits>).

Contributing
- Add support for additional string manipulation functions (e.g., substring extraction, padding).
- Enhance error handling and validation for string operations.
- Submit enhancements to src/tools/utils/strings.hpp in the project repository.

------------------------------------------------------------------
tools/utils/Suppressor.hpp
Suppressor Documentation

Overview
The tools::utils::Suppressor class is a utility designed to temporarily suppress output to a specified file stream 
(e.g., stdout or stderr). This is particularly useful in scenarios where you want to silence output 
from certain parts of your code, such as during testing or when running background tasks. 
The suppressor redirects the output to `/dev/null`, effectively discarding it, and restores the original stream 
when the suppressor is destroyed.
Namespace: tools::utils

Key Components

Constructor
- Suppressor(FILE* s): Initializes the suppressor for the specified file stream (e.g., stdout or stderr).
  - Parameters:
    - s: The file stream to suppress (e.g., stdout, stderr).
  - Behavior:
    - Duplicates the file descriptor of the specified stream.
    - Opens `/dev/null` for writing.
    - Redirects the specified stream to `/dev/null`.

Destructor
- ~Suppressor(): Restores the original file stream and cleans up resources.
  - Behavior:
    - Restores the original file descriptor for the suppressed stream.
    - Closes the backup file descriptor and the `/dev/null` file descriptor.

Usage

1. Suppressing Standard Output
Temporarily suppress output to stdout.
Example:
        #include "tools/utils/Suppressor.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            cout << "This will be printed." << endl;
            {
                Suppressor suppressor(stdout);
                cout << "This will NOT be printed." << endl;
            }
            cout << "This will be printed again." << endl;
            return 0;
        }
        // Output: This will be printed.
        //         This will be printed again.

2. Suppressing Standard Error
Temporarily suppress output to stderr.
Example:
        #include "tools/utils/Suppressor.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            cerr << "This will be printed to stderr." << endl;
            {
                Suppressor suppressor(stderr);
                cerr << "This will NOT be printed to stderr." << endl;
            }
            cerr << "This will be printed to stderr again." << endl;
            return 0;
        }
        // Output: This will be printed to stderr.
        //         This will be printed to stderr again.

Best Practices
- Use the Suppressor class to temporarily silence output in specific code blocks, such as during testing 
or when running background tasks.
- Ensure that the Suppressor is destroyed (goes out of scope) to restore the original output stream.
- Avoid using the Suppressor for long-running tasks, as it may hide important error messages or warnings.

Dependencies
- Internal: None beyond standard C++ libraries.
- External: Unix-specific system calls (<unistd.h>, <fcntl.h>).

Contributing
- Add support for suppressing multiple streams simultaneously.
- Enhance the Suppressor to allow custom redirection targets (e.g., to a log file instead of `/dev/null`).
- Submit enhancements to src/tools/utils/Suppressor.hpp in the project repository.

------------------------------------------------------------------
tools/utils/system.hpp
System Utilities Documentation

Overview
The tools::utils system utilities provide a set of functions for interacting with the system in C++ applications. 
These utilities include functions for retrieving file paths, checking if a process is running, 
executing shell commands, and managing thread sleep. Designed for portability and ease of use, 
these functions are suitable for applications requiring system-level operations such as file path manipulation, 
process monitoring, and command execution.
Namespace: tools::utils

Key Components

Path Utilities
- string get_path(const string& filepath): Extracts the directory path from a given file path.
  - Parameters:
    - filepath: The full file path.
  - Returns: The directory portion of the file path.
- string get_exec_path(): Retrieves the directory path of the currently executing program.
  - Returns: The directory path of the executable, or an empty string if the path cannot be determined.

Process Utilities
- bool is_process_running(const string& processName): Checks if a process with the specified name is currently running.
  - Parameters:
    - processName: The name of the process to check.
  - Returns: true if the process is running, false otherwise.
  - Behavior:
    - Scans the `/proc` directory to find processes matching the given name.
    - Returns true if a matching process is found, otherwise false.

Thread Utilities
- void sleep_ms(long ms): Pauses the current thread for a specified number of milliseconds.
  - Parameters:
    - ms: The number of milliseconds to sleep.

Command Execution
- string execute(const char* cmd): Executes a shell command and returns the output as a string.
  - Parameters:
    - cmd: The command to execute.
  - Returns: The output of the command as a string.
  - Throws: runtime_error if the command execution fails.

Usage

1. Retrieving File Paths
Extract the directory path from a file path and get the executable's directory.
Example:
        #include "tools/utils/system.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            string filepath = "/home/user/file.txt";
            string dir = get_path(filepath);
            cout << "Directory: " << dir << endl; // Output: "Directory: /home/user"

            string execDir = get_exec_path();
            cout << "Executable Directory: " << execDir << endl; // Output: "Executable Directory: /path/to/executable"
            return 0;
        }

2. Checking if a Process is Running
Check if a specific process is running.
Example:
        #include "tools/utils/system.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            bool isRunning = is_process_running("my_process");
            if (isRunning) {
                cout << "Process is running." << endl;
            } else {
                cout << "Process is not running." << endl;
            }
            return 0;
        }

3. Pausing Execution
Pause the current thread for a specified duration.
Example:
        #include "tools/utils/system.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            cout << "Sleeping for 2 seconds..." << endl;
            sleep_ms(2000);
            cout << "Awake!" << endl;
            return 0;
        }

4. Executing Shell Commands
Execute a shell command and capture its output.
Example:
        #include "tools/utils/system.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            try {
                string result = execute("ls -l");
                cout << "Command output: " << result << endl;
            } catch (const runtime_error& e) {
                cerr << "Error: " << e.what() << endl;
            }
            return 0;
        }

Best Practices
- Use get_path and get_exec_path for reliable file path manipulation.
- Use is_process_running to monitor the status of critical processes in your application.
- Use sleep_ms for precise thread sleep durations.
- Use execute for running shell commands and capturing their output, but handle exceptions to avoid crashes.

Dependencies
- Internal: None beyond standard C++ libraries.
- External: Unix-specific system calls (<unistd.h>, <limits.h>, <dirent.h>, <sys/types.h>).

Contributing
- Add support for Windows-specific system operations (e.g., process checking, command execution).
- Enhance execute to handle more complex command execution scenarios (e.g., piping, background execution).
- Submit enhancements to src/tools/utils/system.hpp in the project repository.

------------------------------------------------------------------
tools/utils/Tasks.hpp
Task Management Documentation

Overview
The tools::utils task management utilities provide a robust framework for managing and scheduling tasks in C++ applications. 
The `Task` and `Tasks` classes allow you to create, pause, resume, and stop tasks with flexible scheduling options. 
Tasks can be configured to run immediately, after a delay, or repeatedly at specified intervals. 
The framework also supports logging and exception handling, making it suitable for applications requiring 
background task execution and periodic operations.
Namespace: tools::utils

Key Components

Task Class
- Manages a single task with options for pausing, resuming, and stopping execution.
- Key Features:
  - Pause/Resume: Temporarily pause or resume task execution.
  - Stop: Gracefully stop the task and clean up resources.
  - Immediate Start: Option to run the task immediately or after a delay.
  - Run Count: Specify the number of times the task should run (infinite by default).
  - Exception Handling: Logs exceptions thrown by the task callback.
  - TaskStop Exception: Allows the task to signal completion by throwing `TaskStop`.

Tasks Class
- Manages a collection of `Task` instances, providing high-level control over multiple tasks.
- Key Features:
  - Task Creation: Start tasks with various scheduling options (e.g., timer, delay, repeat).
  - Cleanup: Automatically stops and deletes tasks when the `Tasks` object is destroyed.
  - Move Semantics: Supports move semantics for transferring task ownership.
  - Logging: Integrates with the `Logger` class for logging task events and errors.

Usage

1. Basic Task Creation
Create a task that runs periodically.
Example:
        #include "tools/utils/Tasks.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            Logger logger("TaskLogger");
            Tasks tasks(logger);
            int counter = 0;

            Task& task = tasks.start(100, false, 0, [&]() {
                counter++;
                cout << "Task executed: " << counter << endl;
            });

            this_thread::sleep_for(chrono::milliseconds(500));
            task.stop();
            return 0;
        }

2. Pausing and Resuming Tasks
Pause and resume a task during execution.
Example:
        #include "tools/utils/Tasks.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            Logger logger("TaskLogger");
            Tasks tasks(logger);
            int counter = 0;

            Task& task = tasks.start(100, false, 0, [&]() {
                counter++;
                cout << "Task executed: " << counter << endl;
            });

            this_thread::sleep_for(chrono::milliseconds(300));
            task.pause();
            cout << "Task paused." << endl;
            this_thread::sleep_for(chrono::milliseconds(300));
            task.resume();
            cout << "Task resumed." << endl;
            this_thread::sleep_for(chrono::milliseconds(300));
            task.stop();
            return 0;
        }

3. Stopping Tasks
Stop a task gracefully.
Example:
        #include "tools/utils/Tasks.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            Logger logger("TaskLogger");
            Tasks tasks(logger);
            bool executed = false;

            Task& task = tasks.start(100, false, 0, [&]() {
                executed = true;
                cout << "Task executed." << endl;
            });

            this_thread::sleep_for(chrono::milliseconds(200));
            task.stop();
            cout << "Task stopped." << endl;
            return 0;
        }

4. Running Tasks a Specific Number of Times
Run a task a fixed number of times.
Example:
        #include "tools/utils/Tasks.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            Logger logger("TaskLogger");
            Tasks tasks(logger);
            int counter = 0;

            Task& task = tasks.start(100, true, 5, [&]() {
                counter++;
                cout << "Task executed: " << counter << endl;
            });

            this_thread::sleep_for(chrono::milliseconds(1000));
            cout << "Task finished after " << counter << " executions." << endl;
            return 0;
        }

5. Using TaskStop to Signal Completion
Use `TaskStop` to signal task completion.
Example:
        #include "tools/utils/Tasks.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            Logger logger("TaskLogger");
            Tasks tasks(logger);
            int counter = 0;

            Task& task = tasks.start(100, true, 0, [&]() {
                counter++;
                if (counter == 3) throw TaskStop("Task completed.");
                cout << "Task executed: " << counter << endl;
            });

            this_thread::sleep_for(chrono::milliseconds(1000));
            cout << "Task stopped after " << counter << " executions." << endl;
            return 0;
        }

Best Practices
- Use `Tasks` to manage multiple tasks and ensure proper cleanup.
- Use `TaskStop` to gracefully stop tasks when they complete their work.
- Log exceptions in task callbacks to diagnose issues during execution.
- Use `pause` and `resume` to control task execution dynamically.
- Avoid long-running tasks without periodic checks for `finished` or `paused` states.

Dependencies
- Internal: `tools::utils::Logger` for logging task events and errors.
- External: Standard C++ libraries (<thread>, <atomic>, <mutex>, <condition_variable>, <chrono>).

Contributing
- Add support for task prioritization and scheduling policies.
- Enhance exception handling with custom exception types.
- Submit enhancements to src/tools/utils/Tasks.hpp in the project repository.

------------------------------------------------------------------
tools/utils/Test.hpp
Testing Framework Documentation

Overview
The tools::utils testing framework provides a simple yet powerful way to write and run unit tests in C++ applications. 
It supports test registration, execution, and reporting, with options for filtering tests, handling failures, 
and integrating with ANSI formatting for better readability. The framework is designed to be lightweight and easy to use, 
making it suitable for both small and large projects.
Namespace: tools::utils

Key Components

Test Registration
- `TEST(t)`: Macro to register a test function. The test function must be defined separately and then registered using this macro.
  - Parameters:
    - `t`: The name of the test function to register.
  - Behavior:
    - Registers the test function with its name, file, and line number.
    - The test function should contain assertions to validate the expected behavior.

Test Execution
- `run_tests(const string& filter = "")`: Runs all registered tests, optionally filtered by a keyword.
  - Parameters:
    - `filter`: A keyword to filter tests by name or file. Only tests containing the keyword will be executed.
  - Behavior:
    - Executes each test and logs the result (pass/fail) with timing information.
    - Handles exceptions thrown by tests and logs them as failures.
    - Supports options for fast failure (`TEST_FAILURE_DIES_FAST`), exit on failure (`TEST_FAILURE_EXITS`), 
      and throws on failure (`TEST_FAILURE_THROWS`).

Assertions
- `assert(expr)`: Macro to assert a condition. If the condition is false, the test fails.
  - Parameters:
    - `expr`: The condition to assert.
  - Behavior:
    - Throws an exception with an error message if the condition is false.
    - Can be overridden to use the standard `assert()` function by defining `TEST_CASSERT`.

Failure Handling
- Fast Failure (`TEST_FAILURE_DIES_FAST`): Stops testing immediately after the first failure.
- Exit on Failure (`TEST_FAILURE_EXITS`): Exits the program if any test fails.
- Throw on Failure (`TEST_FAILURE_THROWS`): Throws an exception if any test fails.

ANSI Formatting
- The framework uses ANSI escape codes to format test output, making it easier to read.
- Passed tests are marked with a green checkmark (✓), and failed tests are marked with a red cross (x).

Usage

1. Writing Test Functions
Define test functions separately. Each test function should contain assertions to validate the expected behavior.
Example:
        #include "tools/utils/Test.hpp"
        using namespace std;
        using namespace tools::utils;

        void test_function1() {
            int a = 1, b = 1;
            assert(a == b); // This test will pass
        }

        void test_function2() {
            int a = 1, b = 2;
            assert(a == b); // This test will fail
        }

2. Registering Test Functions
Use the `TEST` macro to register the test functions.
Example:
        TEST(test_function1); // Register test_function1
        TEST(test_function2); // Register test_function2

3. Running Tests
Run all registered tests in the `main` function.
Example:
        int main(int argc, char *argv[]) {
            run_tests(); // Run all tests
            return 0;
        }

4. Filtering Tests
Run only tests that match a specific keyword.
Example:
        int main(int argc, char *argv[]) {
            run_tests("test_function1"); // Run only tests containing "test_function1" in their name or file
            return 0;
        }

5. Handling Failures
Configure the framework to stop on the first failure or exit/throw on failure.
Example:
        // Compile with -DTEST_FAILURE_DIES_FAST -DTEST_FAILURE_EXITS
        int main(int argc, char *argv[]) {
            run_tests(); // Stop and exit on the first failure
            return 0;
        }

Best Practices
- Define test functions separately and use the `TEST` macro to register them.
- Use descriptive names for test functions to make it easier to identify failures.
- Use the `assert` macro to validate conditions in your tests.
- Use the `filter` parameter in `run_tests` to run specific subsets of tests during development.
- Enable `TEST_FAILURE_DIES_FAST` during development to quickly identify and fix failing tests.
- Use ANSI formatting to improve the readability of test output.

Dependencies
- Internal: `tools::utils::ANSI_FMT` (for ANSI formatting), `tools::utils::ERROR` (for error handling).
- External: Standard C++ libraries (<iostream>, <functional>, <vector>, <chrono>).

Contributing
- Add support for test fixtures and setup/teardown functions.
- Enhance the filtering mechanism to support regular expressions.
- Submit enhancements to src/tools/utils/Test.hpp in the project repository.

------------------------------------------------------------------
tools/utils/vectors.hpp
Vector Utilities Documentation

Overview
The tools::utils vector utilities provide a comprehensive set of functions for manipulating and processing vectors in C++. 
These utilities include functions for shifting elements, removing duplicates, merging vectors, filtering elements, 
sorting, reversing, and checking for element existence. Designed for flexibility and ease of use, these functions are 
suitable for a wide range of vector manipulation tasks in C++ applications.
Namespace: tools::utils

Key Components

Vector Manipulation
- `array_shift(vector<T>& vec)`: Removes and returns the first element of a vector.
  - Throws: ERROR if the vector is empty.
- `array_unique(const vector<T>& vec)`: Returns a new vector with duplicate elements removed.
- `array_merge(const vector<T>& vec1, const vector<T>& vec2)`: Merges two vectors into one.
- `array_reverse(vector<T> array)`: Returns a new vector with elements in reverse order.
  - Throws: bad_alloc if memory allocation fails.
- `array_reverse_inplace(vector<T>& array)`: Reverses the elements of a vector in place.
  - Throws: bad_alloc if memory allocation fails.

Vector Filtering and Sorting
- `array_filter(const vector<T>& input, function<bool(const T&)> predicate)`: Filters elements of a vector based on a predicate.
  - Default predicate: Removes empty elements.
- `sort(vector<T>& vec)`: Sorts a vector in ascending order.
- `rsort(vector<T>& vec)`: Sorts a vector in descending order.

Vector Inspection
- `array_dump(vector<T> vec, bool dbg = true)`: Prints the contents of a vector to the console.
  - Parameters:
    - `dbg`: If true, includes a debug message with the vector size.
- `in_array(const Needle& needle, const Container& container)`: Checks if an element exists in a vector or associative container.
  - Works with vectors, maps, and custom objects.
- `vector_equal(const vector<T>& a, const vector<T>& b)`: Checks if two vectors are equal.

Utility Functions
- `array_keys(const Container& container)`: Returns a vector of keys from an associative container (e.g., map).
  - If the container is not associative, returns indices (0 to size-1).

Usage

1. Shifting Elements
Remove and return the first element of a vector.
Example:
        #include "tools/utils/vectors.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            vector<int> vec = {1, 2, 3};
            int shifted = array_shift(vec);
            cout << "Shifted element: " << shifted << endl; // Output: "Shifted element: 1"
            cout << "Remaining vector: ";
            for (int v : vec) cout << v << " "; // Output: "Remaining vector: 2 3"
            return 0;
        }

2. Removing Duplicates
Remove duplicate elements from a vector.
Example:
        #include "tools/utils/vectors.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            vector<int> vec = {1, 2, 2, 3, 4, 4, 5};
            vector<int> unique = array_unique(vec);
            for (int v : unique) cout << v << " "; // Output: "1 2 3 4 5"
            return 0;
        }

3. Merging Vectors
Merge two vectors into one.
Example:
        #include "tools/utils/vectors.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            vector<int> vec1 = {1, 2, 3};
            vector<int> vec2 = {4, 5, 6};
            vector<int> merged = array_merge(vec1, vec2);
            for (int v : merged) cout << v << " "; // Output: "1 2 3 4 5 6"
            return 0;
        }

4. Filtering Elements
Filter elements of a vector based on a predicate.
Example:
        #include "tools/utils/vectors.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            vector<int> vec = {1, 2, 3, 4, 5};
            vector<int> filtered = array_filter(vec, [](int v) { return v % 2 == 0; });
            for (int v : filtered) cout << v << " "; // Output: "2 4"
            return 0;
        }

5. Sorting Vectors
Sort a vector in ascending or descending order.
Example:
        #include "tools/utils/vectors.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            vector<int> vec = {3, 1, 4, 1, 5};
            sort(vec); // Ascending order
            for (int v : vec) cout << v << " "; // Output: "1 1 3 4 5"
            rsort(vec); // Descending order
            for (int v : vec) cout << v << " "; // Output: "5 4 3 1 1"
            return 0;
        }

6. Reversing Vectors
Reverse the elements of a vector.
Example:
        #include "tools/utils/vectors.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            vector<int> vec = {1, 2, 3, 4, 5};
            vector<int> reversed = array_reverse(vec);
            for (int v : reversed) cout << v << " "; // Output: "5 4 3 2 1"
            return 0;
        }

7. Checking for Element Existence
Check if an element exists in a vector or associative container.
Example:
        #include "tools/utils/vectors.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            vector<int> vec = {1, 2, 3, 4, 5};
            bool exists = in_array(3, vec);
            cout << "Element exists: " << exists << endl; // Output: "Element exists: 1"
            return 0;
        }

8. Comparing Vectors
Check if two vectors are equal.
Example:
        #include "tools/utils/vectors.hpp"
        using namespace std;
        using namespace tools::utils;
        int main() {
            vector<int> vec1 = {1, 2, 3};
            vector<int> vec2 = {1, 2, 3};
            bool equal = vector_equal(vec1, vec2);
            cout << "Vectors are equal: " << equal << endl; // Output: "Vectors are equal: 1"
            return 0;
        }

Best Practices
- Use `array_shift` to remove and process the first element of a vector.
- Use `array_unique` to remove duplicates from a vector.
- Use `array_merge` to combine two vectors into one.
- Use `array_filter` to filter elements based on a custom predicate.
- Use `sort` and `rsort` to sort vectors in ascending or descending order.
- Use `array_reverse` and `array_reverse_inplace` to reverse vectors.
- Use `in_array` to check for element existence in vectors or associative containers.
- Use `vector_equal` to compare two vectors for equality.

Dependencies
- Internal: `tools::utils::ERROR` (for error handling).
- External: Standard C++ libraries (<vector>, <unordered_set>, <map>, <functional>, <algorithm>).

Contributing
- Add support for additional container types (e.g., lists, sets).
- Enhance error handling and validation for vector operations.
- Submit enhancements to src/tools/utils/vectors.hpp in the project repository.

------------------------------------------------------------------

------------------------------------------------------------------
