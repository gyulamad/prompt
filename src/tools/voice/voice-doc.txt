Voice Library Documentation

Overview
The tools::voice library provides a suite of C++ classes for handling voice input and output, including recording, 
speech recognition, and text-to-speech synthesis. Designed for real-time audio processing and speech-to-text (STT) 
applications, it integrates components like audio recording, noise detection, speech listening, transcription, and 
speech synthesis into a cohesive framework. This library is ideal for building interactive voice interfaces, such 
as virtual assistants or dictation systems.
Namespace: tools::voice

Key Components

VoiceRecorder
- Purpose: Captures audio from the default input device using PortAudio and stores it in a ring buffer.
- Features: Configurable sample rate, frame size, and buffer duration; supports saving raw PCM data.
- Usage: Base component for feeding audio data into other voice processing classes.

Transcriber
- Purpose: Abstract base class for converting audio data (float samples) into text.
- Features: Subclasses (e.g., WhisperAdapter) implement specific transcription engines.
- Usage: Used by SpeechRecogniser to process recorded speech.

TTS (Text-to-Speech)
- Purpose: Converts text into spoken audio using the espeak command-line tool via a Process wrapper.
- Features: Configurable language, speed, gap between words, and optional beep/think commands; supports 
asynchronous playback.
- Usage: Provides audible feedback or responses in voice applications.

SpeechRecogniser
- Purpose: Coordinates voice recording, noise monitoring, speech detection, and transcription into a unified 
speech recognition pipeline.
- Features: Callback-based architecture for RMS (volume), speech detection, and transcription events.
- Usage: Core class for real-time speech recognition workflows.

SpeechListener
- Purpose: Detects speech segments by listening to noise levels via NoiseMonitor and triggers callbacks when speech 
is identified.
- Features: Accumulates audio during noisy periods and delivers it when silence is detected.
- Usage: Bridges NoiseMonitor and SpeechRecogniser for speech event handling.

NoiseMonitor
- Purpose: Analyzes audio from VoiceRecorder to compute RMS (root mean square) levels and detect noise above a 
threshold.
- Features: Adjustable threshold, decay rate for maximum RMS, and window size; supports muting.
- Usage: Provides real-time noise level monitoring for speech detection.

STT (Speech-to-Text)
- Purpose: Templated class that integrates VoiceRecorder, NoiseMonitor, SpeechListener, and a Transcriber into a 
complete STT system.
- Features: Configurable parameters for all components; callback handlers for RMS, speech, and transcription.
- Usage: High-level interface for speech recognition applications.

WhisperSTT
- Purpose: Specialized STT implementation using the WhisperAdapter (based on the Whisper.cpp library).
- Features: Leverages Whisperâ€™s advanced speech recognition capabilities.
- Usage: Ready-to-use STT solution with Whisper as the transcription engine.

Usage

1. Recording Audio with VoiceRecorder
Create a VoiceRecorder to capture audio and read it into a buffer.
Example:
        #include "tools/voice/voice.hpp"
        using namespace std;
        using namespace tools::voice;
        int main() {
            VoiceRecorder recorder(16000.0, 512, 5); // 16kHz, 512 frames, 5s buffer
            vector<float> buffer(1024);
            Pa_Sleep(1000); // Record for 1 second
            recorder.read_audio(buffer.data(), buffer.size());
            VoiceRecorder::save_as_pcm("output.pcm", buffer);
            return 0;
        }

2. Converting Text to Speech with TTS
Use TTS to speak text aloud with customizable settings.
Example:
        #include "tools/voice/voice.hpp"
        using namespace std;
        using namespace tools::voice;
        int main() {
            map<string, string> replacements = {{"hello", "hi"}};
            TTS tts("en", 150, 10, "beep", "", replacements);
            tts.speak("Hello world!", false, true); // Synchronous with beep
            return 0;
        }

3. Real-Time Speech Recognition with STT
Set up an STT instance for continuous speech recognition with callbacks.
Example:
        #include "tools/voice/voice.hpp"
        using namespace std;
        using namespace tools::voice;
        int main() {
            STT<WhisperAdapter> stt(16000.0, 512, 5, 0.1f, 0.01f, 1024, "model.ggml", "en", 10);
            stt.setRMSHandler([](float vol_pc, float, float, float, bool, bool) {
                cout << "Volume: " << vol_pc * 100 << "%" << endl;
            });
            stt.setTranscribeHandler([](const vector<float>&, const string& text) {
                cout << "Transcription: " << text << endl;
            });
            stt.start();
            Pa_Sleep(5000); // Run for 5 seconds
            stt.stop();
            return 0;
        }

Advanced Usage

Thread Safety
- VoiceRecorder, NoiseMonitor, and SpeechRecogniser use threads for audio streaming and processing. They are 
thread-safe for their primary operations (start/stop), but custom callbacks should handle synchronization if 
accessing shared data.
- TTS uses external processes (espeak), so thread safety depends on the Process class implementation.

Memory Management
- STT owns its component pointers and deletes them in its destructor. Ensure no external references persist after 
STT destruction.
- VoiceRecorder::save_as_pcm and TTS process management require careful resource cleanup (handled automatically in 
destructors).

Custom Transcription
- Extend Transcriber by subclassing and implementing transcribe(). Use with STT<T> for custom engines.
Example:
        #include "tools/voice/voice.hpp"
        using namespace std;
        using namespace tools::voice;
        class CustomTranscriber : public Transcriber {
        public:
            CustomTranscriber() : Transcriber("", nullptr) {}
            string transcribe(const vector<float>& audio_data) override {
                return "Custom transcription";
            }
        };
        int main() {
            STT<CustomTranscriber> stt(16000.0, 512, 5, 0.1f, 0.01f, 1024, "", "", 10);
            stt.setTranscribeHandler([](const vector<float>&, const string& text) {
                cout << text << endl;
            });
            stt.start();
            Pa_Sleep(2000);
            stt.stop();
            return 0;
        }

Best Practices
- Configure VoiceRecorder with a sample rate and buffer size compatible with your transcription engine (e.g., 
16kHz for Whisper).
- Tune NoiseMonitor parameters (threshold_pc, rmax_decay_pc) based on ambient noise levels for optimal speech 
detection.
- Use asynchronous TTS (speak with async=true) for non-blocking applications.
- Handle exceptions in callbacks to prevent crashes during real-time processing.

Dependencies
- Internal: tools::utils (RingBuffer, Process, strings, etc.).
- External: PortAudio (audio I/O), Whisper.cpp (for WhisperSTT), espeak (for TTS), standard C++ libraries.

Contributing
- Add new Transcriber implementations for other speech recognition engines.
- Enhance NoiseMonitor with advanced noise filtering or adaptive thresholds.
- Submit improvements to src/tools/voice/ in the project repository.